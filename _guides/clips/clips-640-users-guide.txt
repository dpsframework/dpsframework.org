CLIPS 6.4  
User’s Guide  
  
by Joseph C. Giarratano, Ph.D. 
Table of Contents
Readme 
1. Just the Facts
2. Following the Rules
3. Adding Details
4. Variable Interests
5. Doing It Up In Style
6. Being Functional
7. How to Be in Control
8. Matters of Inheritance
9. Meaningful Messages
10. Fascinating Facets
11. Handling Handlers
Questions and Answers
Support Information





Readme  



The first step on the road to wisdom is the admission of ignorance. <br>The second step is realizing that you don’t have to blab it to the world. 



This section was formerly called the Preface, but since nobody read it, I renamed it to a more  conventional title that computers users are conditioned to obey. Another suggestion was to call  this the Don’t Readme section, but since people today believe everything they read, I was afraid  they really wouldn’t read it. 

The purpose of a Preface, oops, excuse me, a Readme, is to provide metaknowledge about  the knowledge contained in a book. The term **metaknowledge** means knowledge about the  knowledge. So this description of the Readme is actually metametaknowledge. If you’re either  confused or intrigued at this point, go ahead and read this book anyway because I need all the  readers I can get.  


What Is CLIPS? 

CLIPS is an expert system tool originally developed by the Software Technology Branch (STB),  NASA/Lyndon B. Johnson Space Center. Since its first release in 1986, CLIPS has undergone  continual refinement and improvement. It is now used by thousands of people around the world. 

CLIPS is designed to facilitate the development of software to model human knowledge or  expertise. 

There are three ways to represent knowledge in CLIPS: 

- Rules, which are primarily intended for heuristic knowledge based on experience.  

- Deffunctions and generic functions, which are primarily intended for procedural knowledge.  

- Object-oriented programming, also primarily intended for procedural knowledge. The five  generally accepted features of object-oriented programming are supported: classes,  message-handlers, abstraction, encapsulation, inheritance, and polymorphism. Rules may  pattern match on objects and facts.  

You can develop software using only rules, only objects, or a mixture of objects and rules.

CLIPS has also been designed for integration with other languages such as C and Java. In  fact, CLIPS is an acronym for C Language Integrated Production System. Rules and objects  form an integrated system too since rules can pattern-match on facts and objects. In addition to  being used as a stand-alone tool, CLIPS can be called from a procedural language, perform its  function, and then return control back to the calling program. Likewise, procedural code can be  defined as external functions and called from CLIPS. When the external code completes  execution, control returns to CLIPS. 

If you are already familiar with object-oriented programming in other languages such as  Smalltalk, C++, Objective C, or Java, you know the advantages of objects in developing  software. If you are not familiar with object-oriented programming, you will find that CLIPS is  an excellent tool for learning this new concept in software development.  

What This Book is About 

The CLIPS User’s Guide is an introductory tutorial on the basic features of CLIPS. It is not  intended to be a comprehensive discussion of the entire tool. The companion volume to this  book is the CLIPS Reference Manual, which does provide a complete, comprehensive discussion of  all the topics in this book and much more.  

Who Should Read This Book 

The purpose of the CLIPS User’s Guide is to provide an easy to read, elementary introduction to  expert systems for people with little or no experience with expert systems. 

The CLIPS User’s Guide can be used in the classroom or for self-teaching. The only  prerequisite is that you have a basic knowledge of programming in a high-level language such as  Java, Ada, FORTRAN, C (OK, BASIC if nothing else, but we won’t admit it in public and will  disavow this statement if asked.)  

How To Use This Book 

The CLIPS User’s Guide is designed for people who want a quick introduction to expert system  programming in a hands-on manner. The examples are of a very general nature. Also, since  learning a new language can be a frustrating experience, the writing is in a light, humorous style  (I hope) compared to serious-minded, massive, and intimidating college textbooks. Hopefully, the  humor will not offend anyone with a sense of humor. 

For maximum benefit, you should type in the example programs in the text as you read  through the book. By typing in the examples, you will see how the programs should work and  what error messages occur if you make a mistake. The output for the examples is shown or  described after each example. Finally, you should read the corresponding material in the CLIPS  Reference Manual as you cover each chapter in the CLIPS User’s Guide.  

Like any other programming language, you will only learn programming in CLIPS by writing  programs in it. To really learn expert system programming, you should pick a problem of interest  and write it in CLIPS.  

Acknowledgments 

I greatly appreciate the advice and reviews of this book by many people. Thanks to Gary Riley,  Chris Culbert, Brian Dantes, Bryan Dulock, Steven Lewis, Ann Baker, Steve Mueller, Stephen  Baudendistel, Yen Huynh, Ted Leibfried, Robert Allen, Jim Wescott, Marsha Renals, Pratibha Boloor, Terry Feagin, and Jack Aldridge. Special thanks to Bob Savely for supporting the  development of CLIPS.  


Editor’s Note 

Minor changes have been made to Dr. Giarratano’s original document to reflect changes in  newer versions of CLIPS --- Gary Riley.



























**Chapter 1**  

Just the Facts 

If you ignore the facts, you’ll never worry about being wrong 


This chapter introduces the basic concepts of an expert system. You’ll see how to insert and  remove facts in CLIPS.  


Introduction 


CLIPS is a type of computer language designed for writing applications called expert systems.  An expert system is a program which is specifically intended to model human expertise or  knowledge. In contrast, common programs such as payroll programs, word processors,  spreadsheets, computer games, and so forth, are not intended to embody human expertise or  knowledge. (One definition of an expert is someone more than 50 miles from home and carrying  a briefcase.) 


CLIPS is called an expert system tool because it is a complete environment for developing  expert systems which includes features such as an integrated editor and a debugging tool. The  word shell is reserved for that portion of CLIPS which performs inferences or reasoning. The  CLIPS shell provides the basic elements of an expert system: 


1. **fact-list**, and **instance-list**: Global memory for data  

2. **knowledge-base**: Contains all the rules, the **rule-base**  

3. **inference engine**: Controls overall execution of rules  


A program written in CLIPS may consist of rules, facts, and objects. The inference engine  decides which rules should be executed and when. A rule-based expert system written in CLIPS  is a data-driven program where the facts, and objects if desired, are the data that stimulate  execution via the inference engine.  


This is one example of how CLIPS differs from procedural languages such as Java, Ada,  BASIC, FORTRAN, and C. In procedural languages, execution can proceed without data. That  is, the statements are sufficient in those languages to cause execution. For example, a statement  such as PRINT 2 + 2 could be immediately executed in BASIC. This is a complete statement 


that does not require any additional data to cause its execution. However, in CLIPS, data are  required to cause the execution of rules. 


Originally, CLIPS had capabilities to represent only rules and facts. However, the  enhancements of Version 6.0 allow rules to match objects as well as facts. Also, objects may be  used without rules by sending messages and so the inference engine is no longer necessary if you  use only objects. In chapters 1 through 7, we’ll discuss the facts and rules of CLIPS. The object  features of CLIPS are covered in chapters 8 through 12.  


The Beginning and the End 


To begin CLIPS, just enter the appropriate run command for your system. 

<p class="code-label">You should see the  CLIPS prompt appear as follows:</p> 
```scheme
  CLIPS > 
```


At this point, you can start entering **commands** directly into CLIPS. The mode in which you  are entering direct commands is called the **top-level**. If you have a Graphical User Interface  (GUI) version of CLIPS, you can also **select** some commands using the mouse or arrow keys rather than typing them in. Please refer to the CLIPS Interfaces Guide for a discussion of the  commands supported by the various CLIPS GUIs. For simplicity and uniformity in this book,  we’ll assume the commands are typed in. 


The normal mode of leaving CLIPS is with the exit command. Just type  

```scheme
  (exit)  
```

in response to the CLIPS prompt and then press the carriage return key.  


Making a List 


As with other programming languages, CLIPS recognizes certain keywords. For example, if you  want to put data in the fact-list, you can use the assert command.  


As an example of assert, enter the following right after the CLIPS prompt as shown: 

```scheme

  CLIPS> (assert (duck))  
```

Here the assert command takes (duck) as its argument. Be sure to always press the carriage return  key to send the line to CLIPS. 


You will see the response 

```scheme
  <Fact-1> 
```



which indicates CLIPS has stored the duck fact in the fact-list and given it the identifier 1. The  **angle-brackets** are used as a delimiter in CLIPS to surround the name of an item. CLIPS will  automatically name facts using a sequentially increasing number and list the highest fact-index  when one or more facts is asserted. 


Notice that the (assert) command and its (duck) argument are surrounded by parentheses.  Like many other expert system languages, CLIPS has a LISP-like syntax which uses parentheses  as delimiters. Although CLIPS is not written in LISP, the style of LISP has influenced the  development of CLIPS. 


And Checking It Twice 


Suppose you want to see what’s in the fact-list. If your version of CLIPS supports a GUI, you  may just select the appropriate command from the menu. Alternatively, you can enter commands  from the keyboard. In the following, we’ll describe the keyboard commands since the window  selections are self-explanatory.  


The keyboard command to see facts is with the facts command. Enter (facts) in response to  the CLIPS prompt and CLIPS will respond with a list of facts in the fact-list. Be sure to put  parentheses around the command or CLIPS will not accept it. 

<p class="code-label">The result of the (facts) command  in this example should be </p>
```scheme
 CLIPS> (facts)  
 f-1 (duck) 
 For a total of 1 fact.  
 
CLIPS>  
```
The term f-1 is the **fact identifier** assigned to the (duck) fact by CLIPS. Every fact inserted into  the **fact-list** is assigned a unique fact identifier starting with the letter “f ” and followed by an  integer called the **fact-index**. On starting up CLIPS, and after certain commands such as **clear**  and **reset** (to be discussed in more detail later), the fact- index will be set to one, and then  incremented by one as each new fact is asserted. 


What happens if you try to put a second duck into the fact-list? Let’s try it and see. Assert a  new (duck), then issue a (facts) command as follows 

```scheme
CLIPS> (assert (duck))  
<Fact-1>  
CLIPS> (facts) 
f-1 (duck)  
For a total of 1 fact.  
CLIPS>
```
  
The <Fact-1> message is returned by CLIPS to indicate that the fact already exists. You’ll see  just the original “f-1 (duck)”. This shows that CLIPS will not accept a duplicate entry of a fact.  However, there is an override command, **set-fact-duplication**, which will allow duplicate fact  entry.  
Of course you can put in other, different facts. For example, assert a (quack) fact and then  issue a (facts) command. You’ll see  

```scheme
CLIPS> (assert (quack))  
<Fact-2>  
CLIPS> (facts)  
f-1 (duck)  
f-2 (quack)  
For a total of 2 facts.  
CLIPS>  
```

Notice that the (quack) fact is now in the fact-list.  


Facts may be removed or **retracted**. When a fact is retracted, the other facts do not have  their indices changed, and so there may be “missing” fact-indices. As an analogy, when a football  player leaves a team and is not replaced, the jersey numbers of the other players are not all  adjusted because of the missing number (unless they really hate the guy’s guts and want to forget  he ever played for them).  



Clearing Up the Facts  



The clear command removes all facts from memory, as shown by the following.  

```scheme
CLIPS> (facts)  
f-1 (duck)  
f-2 (quack)  
For a total of 2 facts.  
CLIPS> (clear)  
CLIPS> (facts)  
CLIPS> 
```


The (clear) command essentially restores CLIPS to its original startup state. It clears the memory  of CLIPS and resets the fact-identifier to one. To see this, assert (animal-is duck), then check the  fact-list.  


```scheme
CLIPS> (assert (animal-is duck))  
<Fact-1>  
CLIPS> (facts)  
f-1 (animal-is duck)  
For a total of 1 fact.  
CLIPS>  
```


Notice that (animal-is duck) has a fact-identifier of f-1 because the (clear) command reset the fact  identifiers. The (clear) command actually does more than just remove facts. Besides removing all  the facts, (clear) also removes all the rules, as you’ll see in the next chapter.  


Sensitive Fields and Slurping  



A fact such as (duck) or (quack) is said to consist of a single **field**. A field is a placeholder (named  or unnamed) that may have a value associated with it. As a simple analogy, you can think of a  field as a picture frame. The frame can hold a picture, perhaps a picture of your pet duck (For  those of you who are curious what a picture of a “quack” looks like, it could be (1) a photo of an  oscilloscope trace of a duck saying “quack”, where the signal input comes from a microphone, or  (2) for those of you who are more scientifically inclined, a Fast Fourier Transform of the “quack”  signal, or (3) a TV-huckster selling a miracle cure for wrinkles, losing weight, etc.). Named  placeholders are only used with **deftemplates**, described in more detail in chapter 5.  



The (duck) fact has a single, unnamed placeholder for the value duck. This is an example of a  **single-field** fact. A field is a placeholder for a value. As an analogy to fields, think of dishes  (fields) for holding food (values).  


The **order** of unnamed fields is significant. For example, if a fact was defined  

```scheme
(Brian duck)  
```

and interpreted by a rule as the hunter Brian shot a duck, then the fact 

```scheme
(duck Brian)  
```

would mean that the hunter duck shot a Brian. In contrast, the order of named fields is not  significant, as you’ll see later with deftemplate. 


Actually, it is good software engineering to start the fact with a relation that describes the  fields. A better fact would be  

```scheme
(hunter-game duck Brian)  
```

to imply that the first field is the hunter and the second field is the game.  


A few definitions are now necessary. A list is a group of items with no implied order. Saying  that a list is ordered means that the position in the list is significant. A multifield is a sequence  of fields, each of which may have a value. The examples of (duck Brian) and (Brian duck) are  multifield facts. If a field has no value, the special symbol nil, which means “nothing” may be  used for an empty field as a placeholder. For example,  


```scheme
(duck nil)  
```


would mean that the killer duck bagged no trophies today.  


Note that the nil is necessary to indicate a placeholder, even if it has no value. For example,  think of a field as analogous to a mailbox. There’s a big difference between an empty mailbox,  and no mailbox at all. Without the nil, the fact becomes a single-field fact (duck). If a rule  depends on two fields, it will not work with only one field, as you’ll see later.  


There are a number of different **types** of fields available: **float**, **integer**, **symbol**, **string**,  **external-address**, **fact-address**, **instance-name** and **instance-address**. The type of each  field is determined by the type of **value** stored in the field. In an unnamed field, the type is  determined implicitly by what type you put in the field. In deftemplates, you can explicitly declare  the type of value that a field can contain. The use of explicit types enforces the concepts of  **software engineering**, which is a discipline of programming to produce quality software.  


A **symbol** is one type of field that starts with a printable ASCII character and is followed  optionally by zero or more printable characters. Fields are commonly delimited or bounded, by  one or more spaces or parentheses. For example,  

```scheme
(duck-shot Brian Gary Rey)  
```


However, this could be a legal deftemplate fact if "shot" is defined as the name of a field, while  “Brian Gary Rey” are the values associated with the named field. 

 
CLIPS is case-sensitive. Also, certain characters have special meaning to CLIPS.

```scheme
  " ( ) & | < ~ ; ? $  
```


The `“&”, “|”, and “~”` may not be used as stand-alone symbols or as any part of a symbol. 


 Some characters act as delimiters by ending a symbol. The following characters act as  delimiters for symbols.  
 
- any non-printable ASCII character, including spaces, carriage returns, tabs, and linefeeds 
- double quotes, ` " ` 
- opening and closing parentheses, `() `
- ampersand, `&` 
- vertical bar, `| `
- less than,` <`. Note that this may be the first character of a symbol  
- tilde, `~ `
- semicolon, `;` indicates start of a comment, a carriage return ends it  
- ? and `$?` may not begin a symbol but may be inside it  


The semicolon acts as the start of a comment in CLIPS. If you try to assert a semicolon, CLIPS  will think you’re entering a comment and wait for you to finish. If you accidentally enter a  semicolon in top-level, just type in a closing parenthesis and carriage return. CLIPS will respond  with an error message and the CLIPS prompt will reappear (This is one of the few approved  occasions in life in which it’s necessary to do something wrong to get something right.)  


As you read through this manual, you will learn the special meanings of the characters  above. With the exception of the `“&”, “|”`, and ` “~” `, you may use the others as described.  However, it may be confusing to someone reading your program and trying to understand what  the program is doing. In general, it’s best to avoid using these characters in symbols unless you  have some good reason for using them.  



The following are examples of symbols.  



```racket
duck  
duck1  
duck_soup  
duck-soup  
duck1-1_soup-soup  
d!?#%^ 
```


The second type of field is the string. A string must begin and end with double quotes. The  double quotes are part of the field. Zero or more characters of any kind can appear between the  double quotes. Some examples of strings follow.  


```racket
"duck"  
"duck1"  
"duck/soup"  
"duck soup"  
"duck soup is good!!!"  
```




The third and fourth types of field are numeric fields. A field which represents a number can  be either an integer or floating-point type field. A floating-point type is commonly referred to  simply as a float.  


All numbers in CLIPS are treated as “long long” integers or double-precision floats.  Numbers without a decimal point are treated as integers unless they are outside integer range.  The range is machine dependent on the number of bits, N, used to represent the integer as  follows.  



```racket
-2N-1 
 .  
 .  
 .  
2N-1 - 1 

For 64-bit “long long” integers, this corresponds to a range of numbers  
- 9,223,372,036,854,775,808  
 .  
 .  
 .  
 9,223,372,036,854,775,807  
```
 
 
As some examples of numbers, assert the following data where the last number is in exponential  notation, and uses the “e” or “E” for the power-of-ten.  



```racket
CLIPS> (clear)  
CLIPS> (facts)  
CLIPS> (assert (number 1))  
<Fact-1> 
CLIPS> (assert (x 1.5))  
<Fact-2>  
CLIPS> (assert (y -1))  
<Fact-3>  
CLIPS> (assert (z 65))  
<Fact-4>  
CLIPS> (assert (distance 3.5e5))  
<Fact-5>  
CLIPS> (assert (coordinates 1 2 3))  
<Fact-6>  
CLIPS> (assert (coordinates 1 3 2))  
<Fact-7>  
CLIPS> (facts)  
f-1 (number 1)  
f-2 (x 1.5)  
f-3 (y -1)  
f-4 (z 65)  
f-5 (distance 350000.0)  
f-6 (coordinates 1 2 3)  
f-7 (coordinates 1 3 2)  
For a total of 7 facts.  
CLIPS>  
```



As you can see, CLIPS prints the number entered in exponential notation as 350000.0 because it  converts from power-of-ten format to floating-point if the number is small enough.  


Notice that each fact must start with a symbol such as “number”, “x”, “y”, etc. Before CLIPS  version 6.0, it was possible to enter only a number as a fact. However, now a symbol is required  as the first field. Also, certain reserved words used by CLIPS cannot be used as the first field, but  may be used for other fields. For example, the reserved word not is used to indicate a negated  pattern and may not be used as the first field of a fact.  


A fact consists of one or more fields enclosed in matching left and right parentheses. For  simplicity we’ll only discuss facts in the first seven chapters, but most of the discussion of pattern  matching applies to objects as well. Exceptions are certain functions such as assert and retract  which only apply to facts, not objects. The corresponding ways to handle objects are discussed in  chapters 8–12. 


A fact may be ordered or unordered. All the examples you’ve seen so far are ordered facts  because the order of fields makes a difference. For example, notice that CLIPS considers these as  separate facts although the same values “1”, “2”, and “3” are used in each.  


```racket
f-6 (coordinates 1 2 3)  
f-7 (coordinates 1 3 2)  
```


Ordered facts must use field position to define data. As an example, the ordered fact (duck Brian)  has two fields and so does (Brian duck). However, these are considered as two separate facts by  CLIPS because the order of field values is different. In contrast, the fact (duck-Brian) has only  one field because of the “-” concatenating the two values.  


Deftemplate facts, described in more detail later, are unordered because they use named fields  to define data. This is analogous to the use of structs in C and other languages.  
Multiple fields normally are separated by white space consisting of one or more spaces,  tabs, carriage returns, or linefeeds. For example, enter the following examples as shown and you’ll  see that each stored fact is the same.  

```racket
CLIPS> (clear)  
CLIPS> (assert (The duck says "Quack"))  
<Fact-1>  
CLIPS> (facts)  
f-1 (The duck says "Quack")  
For a total of 1 fact.  
CLIPS> (clear)  
CLIPS> (assert (The duck says "Quack" ))  <Fact-1>  
CLIPS> (facts)  
f-1 (The duck says "Quack")  
For a total of 1 fact.  
CLIPS>  
```



Carriage returns may also be used to improve readability. In the following example, a carriage  return is typed after every field and the asserted fact is the same as before when the fact was  entered on one line.  


```racket
CLIPS> (clear)  
CLIPS> (assert (The  
duck  
says 
"Quack"))  
<Fact-1>  
CLIPS> (facts)  
f-1 (The duck says "Quack")  
For a total of 1 fact.  
CLIPS>  
```



However, be careful if you insert a carriage return inside of a string, as the following example  shows.  


```racket
CLIPS> (assert (The  
duck  
says  
"Quack  
"))  
<Fact-2>  
CLIPS> (facts)  
f-1 (The duck says "Quack")  
f-2 (The duck says "Quack")  
For a total of 2 facts.  
CLIPS>  
```



As you can see, the carriage return embedded in the double quotes was output with the string to  put the closing double quote on the next line. This is important because CLIPS considers fact f-1  as distinct from fact f-2.  



Notice also that CLIPS preserved the uppercase and lowercase letters in the fields of the fact.  That is, the “T” of “The” and the “Q” of “Quack” are uppercase. CLIPS is said to be case sensitive because it distinguishes between uppercase and lowercase letters. For example, assert  the facts (duck) and (Duck) and then issue a (facts) command. You’ll see that CLIPS allows you to  assert (duck) and (Duck) as different facts because CLIPS is case-sensitive.  



The following example is a more realistic case in which carriage returns are used to improve  the readability of a list. To see this, assert the following fact where carriage returns and spaces are  used to put fields at appropriate places on different lines. Dashes or minus signs are used  intentionally to create single fields, so CLIPS will treat items like “fudge sauce” as a single field.  


```racket
CLIPS> (clear)  
CLIPS>  
(assert (grocery-list 
 ice-cream  
 cookies  
 candy  
 fudge-sauce))  
<Fact-1>  
CLIPS> (facts)  
f-1 (grocery-list ice-cream cookies candy fudge-sauce)  For a total of 1 fact.  
CLIPS>  
```



As you can see, CLIPS replaced the carriage returns and tabs with single spaces. While the use of  white space in separating the facts is convenient for a person reading a program, they are  converted to single spaces by CLIPS.  


A Matter of Style  


It is good rule-based programming style to use the first field of a fact to describe the relationship of  the following fields. When used this way, the first field is called a relation. The remaining fields of  the fact are used for specific values. An example is (grocery-list ice-cream cookies candy fudge sauce). The dashes are used to make multiple words fit in a single field.  


Good documentation is even more important in an expert system than in languages such as  Java, C, Ada, etc., because the rules of an expert system are not generally executed in a  sequential manner. CLIPS aids the programmer in writing descriptive facts like this by means of  deftemplates.  


Another example of related facts is (duck), (horse), and (cow). It’s better style to refer to them  as  


```racket
(animal-is duck)  
(animal-is horse)  
(animal-is cow)  
or as the single fact  
(animals duck horse cow)  
```



since the relation animal-is or animals describes their relation and so provides some documentation  to the person reading the code. 



The explicit relations, animal-is and animals, make more sense to a person than the implicit  meaning of (duck), (horse), and (cow). While this example is simple enough that anyone can  figure out the implicit relations, it is an easy trap to fall into to write facts in which the  relationship is not so obvious (In fact, it’s much easier to make something more complicated than  easy, since people are more impressed by complexity than simplicity.)  



Getting Spaced Out  


Since spaces are used to separate multiple fields, it follows that spaces cannot simply be included  in facts. For example,  

```racket
CLIPS> (clear)  
CLIPS> (assert (animal-is walrus))  
<Fact-1>  
CLIPS> (assert ( animal-is walrus ))  
<Fact-1>  
CLIPS> (assert ( animal-is walrus ))  
<Fact-1>  
CLIPS> (facts)  
f-1 (animal-is walrus)  
For a total of 1 fact.  
CLIPS>  
```



Only one fact, (animal-is walrus), is asserted since CLIPS ignores white space and considers all  these facts equivalent. Thus, CLIPS responds with <Fact-1> when you try to enter the last two  duplicate facts. CLIPS normally does not allow duplicate facts to be entered unless you change  the set-fact-duplication setting.  


If you want to include spaces in a fact, you must use double quotes. For example,  

```racket
CLIPS> (clear)  
CLIPS> (assert (animal-is "duck"))  
<Fact-1>  
CLIPS> (assert (animal-is "duck "))  
<Fact-2>  
CLIPS> (assert (animal-is " duck"))  
<Fact-3>  
CLIPS> (assert (animal-is " duck "))  
<Fact-4>  
CLIPS> (facts) 
f-1 (animal-is "duck")  
f-2 (animal-is "duck ")  
f-3 (animal-is " duck")  
f-4 (animal-is " duck ")  
For a total of 4 facts.  
CLIPS>  
```


Note that the spaces make each of these facts different to CLIPS although the meaning is the  same to a person.  


What if you want to include the double quotes in a field? The correct way to put double  quotes in a fact is with the backslash, “\”, as the following example shows.  

```racket
CLIPS> (clear)  
CLIPS> (assert (single-quote "duck"))  
<Fact-1>  
CLIPS> (assert (double-quote "\"duck\""))  
<Fact-2>  
CLIPS> (facts)  
f-1 (single-quote "duck")  
f-2 (double-quote ""duck"")  
For a total of 2 facts.  
CLIPS>  
```


Retract that Fact  



Now that you know how to put facts into the fact-list, it’s time to learn how to remove them.  Removing facts from the fact-list is called retraction and is done with the retract command. To  retract a fact, you must specify the fact index of the fact as the argument of retract. For example,  set up your fact-list as follows. 


```racket
CLIPS> (clear)  
CLIPS> (assert (animal-is duck))  
<Fact-1>  
CLIPS> (assert (animal-sound quack))  
<Fact-2>  
CLIPS> (assert (The duck says "Quack."))  
<Fact-3>  
CLIPS> (facts)  
f-1 (animal-is duck) 
f-2 (animal-sound quack)  
f-3 (The duck says "Quack.")  
For a total of 3 facts.  
CLIPS>  
```


To remove the last fact with index f-3, enter the retract command and then check your facts as  follows.  


```racket
CLIPS> (retract 3)  
CLIPS> (facts)  
f-1 (animal-is duck)  
f-2 (animal-sound quack)  
For a total of 2 facts.  
CLIPS>  
```



What happens if you try to retract a fact that’s already retracted, or a non-existent fact? Let’s try  it and see.  


```racket
CLIPS> (retract 3)  
[PRNTUTIL1] Unable to find fact f-3.  
CLIPS>  
```



Notice that CLIPS issues an error message if you try to retract a non-existent fact. The moral of  this is that you can’t take back what you haven’t given.  
Now let’s retract the other facts as follows. 


```racket
CLIPS> (retract 2)  
CLIPS> (facts)  
f-1 (animal-is duck)  
For a total of 1 fact.  
CLIPS> (retract 1)  
CLIPS> (facts)  
CLIPS>  
```


You can also retract multiple facts at once, as shown by the following.  

```racket
CLIPS> (clear)  
CLIPS> (assert (animal-is duck))  
<Fact-1>  
CLIPS> (assert (animal-sound quack))  
<Fact-2> 
CLIPS> (assert (The duck says "Quack."))  
<Fact-3>  
CLIPS> (retract 1 3)  
CLIPS> (facts)  
f-2 (animal-sound quack)  
For a total of 1 fact.  
CLIPS>  
```


To retract multiple facts, just list the fact-id numbers in the (retract) command.  You can just use (retract *) to retract all the facts, where the “*” indicates all .  

```racket
CLIPS> (clear)  
CLIPS> (assert (animal-is duck))  
<Fact-1>  
CLIPS> (assert (animal-sound quack))  
<Fact-2>  
CLIPS> (assert (The duck says "Quack."))  
<Fact-3>  
CLIPS> (facts)  
f-1 (animal-is duck)  
f-2 (animal-sound quack)  
f-3 (The duck says "Quack.")  
For a total of 3 facts.  
CLIPS> (retract *)  
CLIPS> (facts)  
CLIPS>  
```


Watch that Fact  


CLIPS provides several commands to help you debug programs. One command allows you to  continuously watch facts being asserted and retracted. This is more convenient than having to  type in a (facts) command over and over again and trying to figure out what’s changed in the fact list.  




<p class="code-label">To start watching facts, enter the command (watch facts) as shown in the following example.</p>
```racket
CLIPS> (clear)  
CLIPS> (watch facts)  
CLIPS> (assert (animal-is duck)) 
==> f-1 (animal-is duck)  
<Fact-1>  
CLIPS>  
```


The right double arrow symbol, `==>`, means that a fact is entering memory while the left  double arrow indicates a fact is leaving memory, as shown following.  


```racket
CLIPS> (reset)  
<== f-1 (animal-is duck)  
CLIPS> (assert (animal-is duck))  
==> f-1 (animal-is duck)  
<Fact-1>  
CLIPS> (retract 1)  
<== f-1 (animal-is duck)  
CLIPS> (facts)  
CLIPS>  
```



The (watch facts) command provides a record that shows the dynamic; or changing state of the  fact-list. In contrast, the (facts) command show the static state of the fact-list since it displays the  current contents of the fact-list. To turn off watching facts, enter (unwatch facts).  



There are a number of things you can watch. These include the following, which are  described in more detail in the CLIPS Reference Manual. The comment in CLIPS begins with a  semicolon. Everything after the semicolon is ignored by CLIPS.  



<p class="code-label">The (watch facts) command provides a record that shows the dynamic; or changing state of the  fact-list</p>
```racket
(watch facts)  
; instances used with objects  
(watch instances)  
; slots used with objects  
(watch slots)  
(watch rules)  
(watch activations)  
; messages used with objects  
(watch messages)  
; message-handlers used with objects  
(watch message-handlers)  
(watch generic-functions)  
(watch methods)  
(watch deffunctions)  
; compilations are watched by default 
(watch compilations)  
(watch statistics)  
(watch globals)  
(watch focus)  
; all watches everything  
(watch all)  
```


As you use more of the capabilities of CLIPS, you’ll find these (watch) commands very helpful in  debugging. To turn off a (watch) command, enter an unwatch command. For example, to turn  off watching compilations, enter (unwatch compilations). 





































Chapter 2  
Following the Rules  
If you want to get anywhere in life, don’t break the rules — make the rules!  
Making Good Rules 
To accomplish useful work, an expert system must have rules as well as facts. Since you’ve seen  how facts are asserted and retracted, it’s time to see how rules work. A rule is similar to an IF  THEN statement in a procedural language like Java, C, or Ada. An IF THEN rule can be  expressed in a mixture of natural language and computer language as follows:  
IF certain conditions are true  
THEN execute the following actions  
Another term for the above statement is pseudocode, which literally means false code. While  pseudocode cannot be directly executed by the computer, it serves as a very useful guide to  writing executable code. Pseudocode is also helpful in documenting rules. A translation of rules  from natural language to CLIPS is not very difficult if you keep this IF THEN analogy in mind.  As your experience with CLIPS grows, you’ll find that writing rules in CLIPS becomes easy. You  can either type rules directly into CLIPS or load rules in from a file of rules created by a text  editor. 
The pseudocode for a rule about duck sounds might be 
IF the animal is a duck  
THEN the sound made is quack  
The following is a fact, and a rule named duck which is the pseudocode above expressed in CLIPS  syntax. The name of the rule follows immediately after the keyword defrule. Although you can  enter a rule on a single line, it’s customary to put different parts on separate lines to aid  readability and editing. 
CLIPS> (unwatch facts)  
CLIPS> (clear)  
CLIPS> (assert (animal-is duck))  
<Fact-1> 
CLIPS>  
(defrule duck  
 (animal-is duck)  
=> 
 (assert (sound-is quack)))  
CLIPS>  
If you type in the rule correctly as shown, you should see the CLIPS prompt reappear.  Otherwise, you’ll see an error message. If you get an error message, it is likely that you misspelled  a keyword or left out a parenthesis. Remember, the number of left and right parentheses always  must match in a statement. 
The same rule is shown following with comments added to match the parts of the rule. Also  shown is the optional rule-header comment in quotes, "Here comes the quack". There can be  only one rule-header comment and it must be placed after the rule name and before the first  pattern. Although we’re only discussing pattern matching against facts now, more generally a  pattern can be matched against a pattern entity. A pattern entity is either a fact or an instance of  a user-defined class. Pattern matching on objects will be discussed later. 
CLIPS tries to match the pattern of the rule against a pattern entity. Of course, white space  consisting of spaces, tabs, and carriage returns may be used to separate the elements of a rule to  improve readability. Other comments begin with a semicolon and continue until the carriage  return key is pressed to terminate a line. Comments are ignored by CLIPS.  
; Rule header  
(defrule duck  
 ; Comment  
 "Here comes the quack"  
 ; Pattern  
 (animal-is duck)  
=> ; THEN arrow  
 ; Action  
 (assert (sound-is quack)))  
  
Only one rule name can exist at one time in CLIPS. 
Entering the same rule name, in this case “duck”, will replace any existing rule with that name.  That is, while there can be many rules in CLIPS, there can be only one rule which is named  “duck”. This is analogous to other programming languages in which only one procedure name  can be used to uniquely identify a procedure. 
The general syntax of a rule is shown following.  
(defrule rule_name "optional_comment"  
 (pattern_1) ; Left-Hand Side (LHS)  
 (pattern_2) ; of the rule consisting  
 . ; of elements before  
 . ; the "=>"  
 .  
 (pattern_N)  
=>  
 (action_1) ; Right-Hand Side (RHS)  
 (action_2) ; of the rule consisting  
 . ; of elements after  
 . ; the "=>". The last ")"  
 . ; balances the opening  
 (action_M)) ; "(" to the left of  
 ; "defrule". Be sure all  
 ; your parentheses  
 ; balance or you will  
 ; get error messages  
The entire rule must be surrounded by parentheses. Each of the rule patterns and actions must  be surrounded by parentheses. An action is actually a function which typically has no return  value, but performs some useful action, such as an (assert) or (retract). For example, an action  might be (assert (duck)). Here the function name is “assert” and its argument is “duck”. Notice  that we don’t want any return value such as a number. Instead, we want the fact (duck) to be  asserted. A function in CLIPS is a piece of executable code identified by a specific name, which  returns a useful value or performs a useful side-effect, such as (printout).  
A rule often has multiple patterns and actions. The number of patterns and actions do not  have to be equal, which is why different indices, N and M, were chosen for the rule patterns and  actions.  
Zero or more patterns may be written after the rule header. Each pattern consists of one or  more fields. In the duck rule, the pattern is (animal-is duck), where the fields are “animal-is” and  “duck”. CLIPS attempts to match the patterns of rules against facts in the fact-list. If all the  patterns of a rule match facts, the rule is activated and put on the agenda. The agenda is a  collection of activations which are those rules which match pattern entities. Zero or more  activations may be on the agenda. 
The symbol “=>” that follows the patterns in a rule is called an arrow. The arrow  represents the beginning of the THEN part of an IF-THEN rule (and may be read as “implies”).  
The last part of a rule is the list of zero or more actions that will be executed when the rule  fires. In our example, the one action is to assert the fact (sound-is quack). The term fires means  that CLIPS has selected a certain rule for execution from the agenda.  
  
A program will cease execution when no activations are on the agenda.  
When multiple activations are on the agenda, CLIPS automatically determines which activation  is appropriate to fire. CLIPS orders the activations on the agenda in terms of increasing priority  or salience.  
The part of the rule before the arrow is called the left-hand side (LHS) and the part of the  rule after the arrow is called the right-hand side (RHS). If no patterns are specified, CLIPS  automatically activates the rule when a (reset) command is entered.  
Let’s Get Quacking  
CLIPS always executes the actions on the RHS of the highest priority rule on the agenda. This  rule is then removed from the agenda and the actions of the new highest salience rule is  executed. This process continues until there are no more activations or a command to stop is  encountered.  
You can check what’s on the agenda with the agenda command. For example,  
CLIPS> (agenda)  
0 duck: f-1  
For a total of 1 activation.  
CLIPS>  
The first number “0” is the salience of the “duck” activation, and “f-1” is the fact-identifier of  the fact, (animal-is duck), which matches the activation. If the salience of a rule is not declared  explicitly, CLIPS assigns it the default value of zero, where the possible salience values range  from -10,000 to 10,000. In this book, we’ll use the definition of the term default as meaning the  standard way.  
If there is only one rule on the agenda, that rule will fire. Since the LHS pattern of the duck sound rule is  
(animal-is duck) 
this pattern will be satisfied by the fact (animal-is duck) and so the duck-sound rule should fire.  
Each field of the pattern is said to be a literal constraint. The term literal means having  a constant value, as opposed to a variable whose value is expected to change. In this case, the  literals are “animal-is” and “duck”.  
To make a program run, just enter the run command. Type (run) and press the carriage  return key. Then do a (facts) to check that the fact was asserted by the rule.  
CLIPS> (run)  
CLIPS> (facts)  
f-1 (animal-is duck)  
f-2 (sound-is quack)  
For a total of 2 facts.  
CLIPS>  
Before going on, let’s save the duck rule with the save command so that you don’t have to type it  in again (if you haven’t already saved it in an editor). Just enter a command such as  
(save "duck.clp")  
to save the rule from CLIPS memory to disk and name the file “duck.clp” where the “.clp” is  simply a convenient extension to remind us this is a CLIPS source code file. Note that saving the  code from CLIPS memory like this will only preserve the optional rule-header comment in  quotes and not any semicolon comments.  
Kick your Duck  
An interesting question may occur to you at this time. What if you (run) again? There is a rule  and a fact which satisfies the rule, so the rule should fire. However, if you try this and (run) again,  you’ll see that the rule won’t fire. This may be somewhat frustrating. However, before you do  something drastic to ease your frustration — like kicking your pet duck — you need to know a  little more about some basic principles of expert systems.  
A rule is activated if its patterns are matched by a  
1. a brand new pattern entity that did not exist before or,  
2. a pattern entity that did exist before but was retracted and reasserted, i.e., a “clone” of  the old pattern entity, and thus now a new pattern entity. 
The rule, and indices of the matching patterns, is the activation. If either the rule or the pattern  entity, or both change, the activation is removed. An activation may also be removed by a  command or an action of another rule that fired before and removed the conditions necessary for  activation.  
The Inference Engine sorts the activations according to their salience. This sorting process is  called conflict resolution because it eliminates the conflict of deciding which rule should fire  next. CLIPS executes the RHS of the rule with the highest salience on the agenda, and removes  the activation. This execution is called firing the rule in analogy with the firing of a neuron. A  neuron emits a voltage pulse when an appropriate stimulus is applied. After a neuron fires, it  undergoes refraction and cannot fire again for a certain period of time. Without refraction,  neurons would just keep firing over and over again on exactly the same stimulus.  
Without refraction, expert systems always would be caught in trivial loops. That is, as soon as  a rule fired, it would keep firing on that same fact over and over again. In the real world, the  stimulus that caused the firing eventually would disappear. For example, a real duck might swim  away or get a job in the movies. However, in the computer world, once data is stored, it stays  there until explicitly removed or the power is turned off.  
The following example shows activations and firing of a rule. Notice that the (watch)  commands are used to more carefully show every fact and activation. The arrow going to the  right means an entering fact or activation while an arrow to the left would mean an exiting fact  or activation.  
; Comments in blue/italics have been  
; added for explanation. You will  
; not see these in the actual output  
CLIPS> (clear)  
CLIPS>  
(defrule duck  
 (animal-is duck)  
=>  
 (assert (sound-is quack)))  
CLIPS> (watch facts)  
CLIPS> (watch activations)  
CLIPS> (assert (animal-is duck))  
==> f-1 (animal-is duck)  
; Activation salience is 0 by default,  
; then rule name:pattern entity index  
==> Activation 0 duck: f-1 
<Fact-1>  
; Notice that duplicate fact  
; cannot be entered  
CLIPS> (assert (animal-is duck))  
<Fact-1>  
CLIPS> (agenda)  
0 duck: f-1  
For a total of 1 activation.  
CLIPS> (run)  
==> f-2 (sound-is quack)  
; Nothing on agenda after rule fires  
; Even though fact matches rule,  
; refraction will not allow this  
; activation because the rule already  
; fired on this fact  
CLIPS> (agenda)  
CLIPS> (facts)  
f-1 (animal-is duck)  
f-2 (sound-is quack)  
For a total of 2 facts.  
CLIPS> (run)  
CLIPS>  
You can make the rule fire again if you retract the fact and then assert it as a new fact.  Show Me the Rules  
Sometimes you may want to see a rule while you’re in CLIPS. There’s a command called  ppdefrule – the pretty print rule – that prints a rule. To see a rule, specify the rule name as an  argument to ppdefrule. For example,  
CLIPS> (ppdefrule duck)  
(defrule MAIN::duck  
 (animal-is duck)  
 =>  
 (assert (sound-is quack)))  
CLIPS> 
CLIPS puts different parts of the rule on different lines for the sake of readability. The patterns  before the arrow are still considered the LHS and the actions after the arrow are still considered  the RHS of the rule. The term MAIN refers to the MAIN module that this rule is in by default.  You can define modules to put rules in analogous to the statements that may be put in different  
packages, modules, procedures, or functions of other programming languages. The use of  modules make it easier to write expert systems having many rules since these may be grouped  together with their own agendas for each module. For more information, see the CLIPS Reference  Manual.  
What if you want to print a rule but can’t remember the name of the rule? No problem. Just  use the rules command in response to a CLIPS prompt and CLIPS will print out the names of  all the rules. For example, enter  
CLIPS> (rules)  
duck  
For a total of 1 defrule.  
CLIPS>  
Write to Me  
Besides asserting facts in the RHS of rules, you also can print out information using the  printout function. CLIPS also has a carriage return/linefeed keyword called crlf which is very  useful in improving the appearance of output by formatting it on different lines. For a change, the  crlf is not included in parentheses. As an example,  
CLIPS>  
(defrule duck  
 (animal-is duck)  
=>  
 ;; Be sure to type in the "t"  
 (printout t "quack" crlf))  
==> Activation 0 duck: f-1  
CLIPS> (run)  
quack  
CLIPS>  
The output is the text within the double quotes. Be sure to type the letter “t” following the  printout command. This tells CLIPS to send the output to the standard output device of  your computer. Generally, the standard output device is your terminal (hence the letter “t” after 
printout). However, this may be redefined so that the standard output device is some other device,  such as a modem or disk.  
Other Features  
The declare salience command provides explicit control over which rules will be put on the  agenda. You must be careful in using this feature too freely lest your program become too  controlled. One way to make a rule fire again is to force the rule to be re-activated by the  refresh rule command.  
The load command loads in the rule that you had previously saved to disk in the file  “duck.clp” or whatever name and directory that you had saved it under. You can load a file of  rules made on a text editor into CLIPS using the load command.  
A faster way to load files is to first save them in a machine readable binary format with the  save binary command called bsave. The load binary command, bload, can then be used to  read these binary rules into CLIPS memory much faster since the files do not have to be re interpreted by CLIPS.  
Two other useful commands allow you to save and load facts using a file. These are save facts and load-facts. The (save-facts) will save all the facts in the fact-list to a file while (load-facts)  will load in the facts from a file into the fact-list.  
The batch command allows you to execute commands from a file as if they were typed in at  the top-level. Another useful command provides an interface to your operating system. The  system command allows the execution of operating system commands or executables within  CLIPS. For more information on all these topics, see the CLIPS Reference Manual. 
Chapter 3  
Adding Details  
It’s not the big picture that is the problem—it’s the details  
In the first two chapters, you learned the fundamentals of CLIPS. Now you will see how to build  on that foundation to create more powerful programs.  
Stop And Go  
Until now, you’ve only seen the simplest type of program consisting of just one rule. However,  expert systems consisting of only one rule are not very useful. Practical expert systems may  consist of hundreds or thousands of rules. Let’s now take a look at an application requiring  multiple rules.  
Suppose you wanted to write an expert system to determine how a mobile robot should  respond to a traffic light. It is best to write this type of problem using multiple rules. For example,  the rules for the red and green light situations can be written as follows.  
(defrule red-light  
 (light red)  
=>  
 (printout t "Stop" crlf))  
(defrule green-light  
 (light green)  
=>  
 (printout t "Go" crlf))  
After the rules have been entered into CLIPS, assert a fact (light red) and run. You’ll see “Stop”  printed. Now assert a (light green) fact and run. You should see “Go” printed.  
Take a Walk  
If you think about it, other possibilities beside the simple red, green, and yellow cases exist. Some  traffic lights also have a green arrow for protected left turns. Some have a hand that lights up to 
indicate whether a person can walk or not. Some have signs that say walk or don’t walk. So  depending on whether our robot is walking or driving, it may have to pay attention to different  signs.  
The information about walking or driving must be asserted in addition to information about  the status of the light. Rules can be made to cover these conditions, but they must have more  than one pattern. For example, suppose we want a rule to fire if the robot is walking and if the  walk-sign says walk. A rule could be written as follows:  
(defrule take-a-walk  
 (status walking)  
 (walk-sign walk)  
=>  
 (printout t "Go" crlf))  
The above rule has two patterns. Both patterns must be satisfied by facts in the fact-list for the  rule to fire. To see how this works, enter the rule and then assert the facts (status walking) and  (walk-sign walk). When you (run), the program will print out “Go” since both patterns are  satisfied and the rule is fired.  
You can have any number of patterns or actions in a rule. The important point to realize is  that the rule is placed on the agenda only if all the patterns are satisfied by facts. This type of  restriction is called a logical AND conditional element (CE) in reference to the AND  relation of Boolean logic. An AND relation is said to be true only if all its conditions are true.  
Because the patterns are of the logical AND type, the rule will not fire if only one of the  patterns is satisfied. All facts must be present before the LHS of a rule is satisfied and the rule is  placed on the agenda.  
A Question of Strategy  
The word strategy was originally a military term for the planning and operations of warfare.  Today, the term strategy is commonly used in business (because business is war) to refer to the  high-level plans of an organization in achieving its goals, e.g., “Make a lot of money by selling  more greasy hamburgers than anyone else in the world!”  
In expert systems, one use of the term strategy is in conflict resolution of activations. Now you  might say, “Well, I’ll just design my expert system so that only one rule can possibly be activated  at one time. Then there is no need for conflict resolution.” The good news is that if you succeed,  conflict resolution is indeed unnecessary. The bad news is that this success proves that your 
application can be well represented by a sequential program. So you should have coded it in C,  Java, or Ada in the first place and not bothered writing it as an expert system.  
CLIPS offers seven different modes of conflict resolution: depth, breadth, LEX, MEA,  complexity, simplicity, and random. It’s difficult to say that one is clearly better than another  without considering the specific application. Even then, it may be difficult to judge which is  “best.” For more information on the details of these strategies, see the CLIPS Reference Manual.  
The depth strategy is the standard default strategy of CLIPS. The default setting is  automatically set when CLIPS is first started. Afterwards, you can change the default setting. In  the depth strategy, new activations are placed on the agenda after activations with higher  salience, but before activations with equal or lower salience. All this simply means is that the  agenda is ordered from highest to lowest salience.  
  
In this book, all discussions and examples will assume depth strategy.  
Now that all these different optional settings are available, be sure that before you run an expert  system developed by someone else, that your settings are the same as theirs. Otherwise, you may  find the operation is inefficient or even incorrect. In fact, it’s a good idea to explicitly encode all  the settings in any system that you develop so that it will be configured properly.  
Gimme Deffacts  
As you work with CLIPS, you may become tired of typing in the same assertions from the top level. If you are going to use the same assertions every time a program is run, you can first load  assertions from a disk using a batch file. An alternative way to enter facts is by using the define  facts keyword, deffacts. For example,  
CLIPS> (unwatch facts)  
CLIPS> (unwatch activations)  
CLIPS> (clear)  
CLIPS>  
(deffacts walk "Some facts about walking"  
 ; status fact to be asserted  
 (status walking)  
 ; walk-sign fact to be asserted  
 (walk-sign walk))  
CLIPS> (reset)  
; reset causes facts from  
; deffacts to be asserted 
CLIPS> (facts)  
f-1 (status walking)  
f-2 (walk-sign walk)  
For a total of 2 facts.  
CLIPS>  
The required name of this deffacts statement, walk, follows the deffacts keyword. Following the  name is an optional comment in double quotes. Like the optional comment of a rule, the  (deffacts) comment will be retained with the (deffacts) after it’s been loaded by CLIPS. After the  name or comment are the facts that will be asserted in the fact-list. The facts in a deffacts  statement are asserted using the CLIPS (reset) command.  
The (reset) has an advantage compared to a (clear) command in that (reset) doesn’t get rid of  all the rules. The (reset) leaves your rules intact. Like (clear), it removes all activated rules from  the agenda and also removes all old facts from the fact-list. Giving a (reset) command is a  recommended way to start off program execution, especially if the program has been run before  and the fact-list is cluttered with old facts.  
In summary, the (reset) does two things for facts.  
1. It removes existing facts from the fact-list, which may remove activated rules from the  agenda.  
2. It asserts facts from existing (deffacts) statements.  
Actually, the (reset) also does corresponding operations on objects. It deletes instances and  asserts instances from definstances.  
Selective Elimination  
The undeffacts command excises a (deffacts) from asserting facts by eliminating the deffacts  from memory. For example,  
CLIPS> (undeffacts walk)  
CLIPS> (reset)  
CLIPS> (facts)  
CLIPS>  
This example demonstrates how the (deffacts) walk has been excised. To restore a deffacts  statement after an (undeffacts) command, you must enter the deffacts statement again. In  addition to facts, CLIPS also allows you to eliminate rules selectively by using the undefrule. 
Watch It!  
You can watch rules firing and watch activations on the agenda. The watch statistics prints information about the number of rules fired, run time, rules per second, mean number of  facts, maximum number of facts, mean number of activations, and maximum number of  activations. The statistics information may be useful in tuning up an expert system to optimize  its speed. Another command, called watch compilations, shows information when rules are  being loaded. The watch all command will watch everything.  
Printing of watch information to the screen or to disk with the dribble command will slow  down your program somewhat because CLIPS uses more time to print or to save to disk. The  dribble-on command will store all input and output entered at the command prompt to a disk  file until the dribble-off command is entered. This is convenient in providing a permanent  record of everything that happens. These commands are as follows.  
(dribble-on <filename>)  
(dribble-off <filename>)  
Another useful debugging command is (run) which takes an optional argument of the number of  rule firings. For example, a (run 21) command would tell CLIPS to run the program and then  stop after 21 rule firings. A (run 1) command allows you to step through a program firing one rule  at a time.  
Just like many other programming languages, CLIPS also gives you the capability of setting  breakpoints. A breakpoint is simply an indicator to CLIPS to stop execution just prior to  executing a specified rule. A breakpoint is set by the set-break command. The remove-break command will remove a breakpoint that has been set. The show-breaks will list all the rules  which have breakpoints set. The syntax of these commands for the argument <rulename> is  shown following.  
(set-break <rulename>)  
(remove-break <rulename>)  
(show-breaks)  
A Good Match  
You may encounter a situation in which you are certain a rule should be activated but isn’t. While  it is possible that this is due to a bug in CLIPS, it’s not very likely because of the great skill of the  people who programmed CLIPS (NOTE: PAID COMMERCIAL ANNOUNCEMENT FOR  THE DEVELOPERS). 
In most cases, the problem occurs because of the way that you wrote the rule. As an aid to  debugging, CLIPS has a command called matches that can tell you which patterns in a rule  match facts. Patterns which do not match prevent the rule from becoming activated. One  common reason that a pattern won’t match a fact results from misspelling an element in the  pattern or in the assertion of the fact.  
The argument of (matches) is the name of the rule to be checked for matches. To see how  (matches) works, first (clear), then enter the following rule.  
(defrule take-a-vacation  
 ; Conditional element 1  
 (work done)  
 ; Conditional element 2  
 (money plenty)  
 ; Conditional element 3  
 (reservations made)  
=>  
 (printout t "Let's go!!!" crlf))  
The following shows how (matches) is used. Enter the commands as shown. Notice that (watch  facts) is turned on. This is a good idea when you are asserting facts manually since it gives you an  opportunity to check the spelling of facts.  
CLIPS> (watch facts)  
CLIPS> (assert (work done))  
==> f-1 (work done)  
<Fact-1>  
CLIPS> (matches take-a-vacation)  
Matches for Pattern 1  
f-1  
Matches for Pattern 2  
 None  
Matches for Pattern 3  
 None  
; CE is conditional element 
Partial matches for CEs 1 - 2  
 None  
Partial matches for CEs 1 - 3  
 None  
Activations 
 None  
; The return value indicates the total patterns  
; matched, the total partial matches, and the  
; total activations 
(1 0 0) 
CLIPS>  
The fact with fact-identifier f-1 matches the first pattern or conditional element in the rule and is  reported by (matches). Given that a rule has N patterns, the term partial matches refers to any  set of matches of the first N-1 patterns with facts. That is, the partial matches begin with the first  pattern in a rule and end with any pattern up to but not including the last (Nth) pattern. As soon  
as one partial match cannot be made, CLIPS does not check any further. For example, a rule  with four patterns would have partial matches of the first and second patterns and also of the  first, second, and third patterns. If all N patterns match, the rule will be activated.  
Other Features  
Some additional commands are useful with deffacts. For example, the command list-deffacts will list the names of currently loaded deffacts in CLIPS. Another useful command is  ppdeffacts which prints the facts stored in a deffacts.  
Other functions allow you to manipulate strings easily:  
assert-string: Performs a string assertion by taking a string as argument and asserted as a  non-string fact.  
str-cat: Constructs a single-quoted string from individual items by string concatenation.  str-index: Returns a string index of the first occurrence of a substring.  
sub-string: Returns a substring from a string.  
str-compare: Performs a string compare.  
str-length: Returns the string length which is the length of a string.  
sym-cat: Returns a concatenated symbol.  
If you want to printout a multifield variable without parentheses, the simplest way is by using the  string implode function, implode$.
Chapter 4  
Variable Interests  
Nothing changes more than change  
The type of rules that you’ve seen so far illustrates simple matching of patterns to facts. In this  chapter, you’ll learn very powerful ways to match and manipulate facts.  
Let’s Get Variable  
Just as with other programming languages, CLIPS has variables to store values. Unlike a fact,  which is static or unchanging, the contents of a variable are dynamic as the values assigned to  it change. In contrast, once a fact is asserted, it’s fields can only be modified by retracting and  asserting a new fact with the changed fields, Even the modify action (described later in the chapter  on deftemplate) acts by retracting and asserting a modified fact, as you can see by checking the  fact-index.  
The name of a variable, or variable identifier, is always written by a question mark  followed by a symbol that is the name of the variable. The general format is  
?<variable-name>  
Global variables, to be described in more detail later, have a slightly different syntax.  
Just as in other programming languages, variable names should be meaningful for good style.  Some examples of valid variable names follow.  
?x  
?noun  
?color  
?sensor  
?valve  
?ducks-eaten  
Before a variable can be used, it should be assigned a value. As an example of a case where a  value is not assigned, try to enter the following and CLIPS will respond with the error message  shown. 
CLIPS> (unwatch all)  
CLIPS> (clear)  
CLIPS>  
(defrule test  
=>  
 (printout t ?x crlf))  
[PRCCODE3] Undefined variable x referenced in RHS of defrule.  
ERROR:  
(defrule MAIN::test  
 =>  
 (printout t ?x crlf))  
CLIPS>  
CLIPS gives an error message when it cannot find a value bound to ?x. The term bound means  the assignment of a value to a variable. Only global variables are bound in all rules. All other  variables are only bound within a rule. Before and after a rule fires, non-global variables are not  bound and so CLIPS will give an error message if you try to query a non-bound variable.  
Be Assertive  
One common use of variables is to match a value on the LHS and then assert this bound  variable on the RHS. For example, enter  
(defrule make-quack  
 (duck-sound ?sound)  
=>  
 (assert (sound-is ?sound)))  
Now assert (duck-sound quack), then (run) the program. Check the facts and you’ll see that the  rule has produced (sound-is quack) because the variable ?sound was bound to quack.  
Of course, you also can use a variable more than once. For example, enter the following. Be  sure to do a (reset) and assert (duck-sound quack) again.  
(defrule make-quack  
 (duck-sound ?sound)  
=>  
 (assert (sound-is ?sound ?sound))) 
When the rule fires, it will produce (sound-is quack quack) since the variable ?sound is used twice.  What the Duck Said  
Variables also are used commonly in printing output, as in  
(defrule make-quack  
 (duck-sound ?sound)  
=>  
 (printout t "The duck said "  
 ?sound crlf))  
Do a (reset), enter this rule, and assert the fact and then (run) to find out what the duck said. How  would you modify the rule to put double quotes around quack in the output?  
More than one variable may be used in a pattern, as the following example shows.  
CLIPS> (clear)  
CLIPS>  
(defrule whodunit  
 (duckshoot ?hunter ?who)  
=>  
 (printout t ?hunter " shot "  
 ?who crlf))  
CLIPS> (assert (duckshoot Brian duck))  
<Fact-1>  
; Duck dinner tonight!  
CLIPS> (run)  
Brian shot duck  
CLIPS> (assert (duckshoot duck Brian))  
<Fact-2>  
; Brian dinner tonight!  
CLIPS> (run)  
duck shot Brian  
; Missing third field  
CLIPS> (assert (duckshoot duck))  
<Fact-3>  
; Rule doesn't fire,  
; no output
CLIPS> (run)  
CLIPS>  
Notice what a big difference the order of fields makes in determining who shot who. You can also  see that the rule did not fire when the fact (duckshoot duck) was asserted. The rule was not  activated because no field of the fact matched the second pattern constraint, ?who.  
The Happy Bachelor  
Retraction is very useful in expert systems and usually done on the RHS rather than at the top level. Before a fact can be retracted, it must be specified to CLIPS. To retract a fact from a rule,  the fact-address first must be bound to a variable on the LHS.  
There is a big difference between binding a variable to the contents of a fact and binding a  variable to the fact-address. In the examples that you’ve seen such as (duck-sound ?sound), a  variable was bound to the value of a field. That is, ?sound was bound to quack. However, if you  want to remove the fact whose contents are (duck-sound quack), you must first tell CLIPS the  address of the fact to be retracted.  
The fact-address is specified using the left arrow, “<-”. To create this, just type a “<”  symbol followed by a “-”. As an example of fact retraction from a rule,  
CLIPS> (clear)  
CLIPS> (assert (bachelor Dopey))  
<Fact-1>  
CLIPS> (facts)  
f-1 (bachelor Dopey)  
For a total of 1 fact.  
CLIPS>  
(defrule get-married  
 ?duck <- (bachelor Dopey)  
=>  
 (printout t "Dopey is now happily married "  
 ?duck crlf)  
 (retract ?duck))  
CLIPS> (run)  
Dopey is now happily married <Fact-1>  
CLIPS> (facts)  
CLIPS> 
Notice that the (printout) prints the fact-index of ?duck, <Fact-1>, since the left arrow bound the  address of the fact to ?duck. Also, there is no fact (bachelor Dopey) because it has been retracted.  
Variables can be used to pick up a fact value at the same time as an address, as shown in the  following example. For convenience, a (deffacts) has also been defined.  
CLIPS> (clear)  
CLIPS>  
(defrule marriage  
 ?duck <- (bachelor ?name)  
=>  
 (printout t ?name  
 " is now happily married"  
 crlf)  
 (retract ?duck))  
CLIPS>  
(deffacts good-prospects  
 (bachelor Dopey)  
 (bachelor Dorky)  
 (bachelor Dicky))  
CLIPS> (reset)  
CLIPS> (run)  
Dicky is now happily married  
Dorky is now happily married  
Dopey is now happily married  
CLIPS>  
Notice how the rule fired on all facts that matched the pattern (bachelor ?name). CLIPS also has  a function called fact-index which can be used to return the fact index of a fact address. 
It’s Not Important  
Instead of binding a field value to a variable, the presence of a nonempty field can be detected  alone using a wildcard. For example, suppose you’re running a dating service for ducks, and a  duckette asserts that she only dates ducks whose first name is Dopey. Actually, two criteria are in  
this specification since there is an implication that the duck must have more than one name. So a  plain (bachelor Dopey) isn’t adequate because there is only one name in the fact.  
This type of situation, in which only part of the fact is specified, is very common and very  important. To solve this problem, a wildcard can be used to match the Dopeys. 
The simplest form of wildcard is called a single-field wildcard and is shown by a question  mark, “?”. The “?” is also called a single-field constraint. A single-field wildcard stands for  exactly one field, as shown following.  
CLIPS> (clear)  
CLIPS>  
(defrule dating-ducks  
 (bachelor Dopey ?)  
=>  
 (printout t "Date Dopey"  
 crlf))  
CLIPS>  
(deffacts duck  
 (bachelor Dicky)  
 (bachelor Dopey)  
 (bachelor Dopey Mallard)  
 (bachelor Dinky Dopey)  
 (bachelor Dopey Dinky Mallard))  
CLIPS> (reset)  
CLIPS> (run)  
Date Dopey  
CLIPS>  
The pattern includes a wildcard to indicate that Dopey’s last name is not important. So long as  the first name is Dopey and there is any last name (but no middle names), the rule will be satisfied  and fire. Because the pattern has three fields of which one is a single-field wildcard, only facts of  exactly three fields can satisfy it. In other words, only Dopeys with exactly two names can satisfy  this duckette.  
Suppose you want to specify Dopeys with exactly three names? All that you’d have to do is  write a pattern like  
(bachelor Dopey ? ?)  
or, if only persons with three names whose middle name was Dopey,  
(bachelor ? Dopey ?)  
or, if only the last name was Dopey, as in the following:  
(bachelor ? ? Dopey) 
Another interesting possibility occurs if Dopey must be the first name, but only those Dopeys with  two or three names are acceptable. One way of solving this problem is to write two rules. For  example  
(defrule eligible  
 (bachelor Dopey ?)  
=>  
 (printout t "Date Dopey" crlf))  
(defrule eligible-three-names  
 (bachelor Dopey ? ?)  
=>  
 (printout t "Date Dopey" crlf))  
Enter and run this and you’ll see that Dopeys with both two and three names are printed. Of  course, if you don’t want anonymous dates, you need to bind the Dopey names with a variable  and print them out.  
Going Wild  
Rather than writing separate rules to handle each field, it’s much easier to use the multifield  wildcard. This is a dollar sign followed by a question mark, “$?”, and represents zero or more  fields. Notice how this contrasts with the single-field wildcard which must match exactly one field.  
The two rules for dates can now be written in a single rule as follows.  
CLIPS> (clear)  
CLIPS>  
(defrule dating-ducks  
 (bachelor Dopey $?)  
=>  
 (printout t "Date Dopey" crlf))  
CLIPS>  
(deffacts duck  
 (bachelor Dicky)  
 (bachelor Dopey)  
 (bachelor Dopey Mallard)  
 (bachelor Dinky Dopey)  
 (bachelor Dopey Dinky Mallard))  
CLIPS> (reset) 
CLIPS> (run)  
Date Dopey  
Date Dopey  
Date Dopey  
CLIPS>  
Wildcards have another important use because they can be attached to a symbolic field to create  a variable such as ?x, $?x, ?name, or $?name. The variable can be a single-field variable or a  multifield variable depending on whether a “?” or “$?” is used on the LHS. Note that on the  RHS only a ?x is used, where the “x” can be any variable name. You can think of the “$” as a  
function whose argument is a single-field wildcard or a single-field variable and returns a  multifield wildcard or a multifield variable, respectively.  
As an example of a multifield variable, the following version of the rule also prints out the  name field(s) of the matching fact because a variable is equated to the name field(s) that match:  
CLIPS>  
(defrule dating-ducks  
 (bachelor Dopey $?name)  
=>  
 (printout t "Date Dopey " ?name crlf))  
CLIPS> (reset)  
CLIPS> (run)  
Date Dopey (Dinky Mallard)  
Date Dopey (Mallard)  
Date Dopey ()  
CLIPS>  
As you can see, on the LHS, the multifield pattern is $?name but is ?name when used as a variable  on the RHS. When you enter and run, you’ll see the names of all eligible Dopeys. The multifield  wildcard takes care of any number of fields. Also, notice that multifield values are returned  enclosed in parentheses.  
Suppose you wanted a match of all ducks who had a Dopey somewhere in their name, not  necessarily as their first name. The following version of the rule would match all facts with a  Dopey in them and then print out the names:  
CLIPS>  
(defrule dating-ducks  
 (bachelor $?first Dopey $?last)  
=> 
 (printout t "Date "  
 ?first  
 " Dopey "  
 ?last crlf))  
CLIPS> (reset)  
CLIPS> (run)  
Date () Dopey (Dinky Mallard)  
Date (Dinky) Dopey ()  
Date () Dopey (Mallard)  
Date () Dopey ()  
CLIPS>  
The pattern matches any names that have a Dopey anywhere in them.  
Single- and multifield wildcards can be combined. For example, the pattern  (bachelor ? $? Dopey ?)  
means that the first and last names can be anything and that the name just prior to the last must  be Dopey. This pattern also requires that the matching fact will have at least four fields, since the  “$?” matches zero or more fields and all the others must match exactly four.  
Although multifield variables can be essential for pattern matching in many cases, their  overuse can cause much inefficiency because of increased memory requirements and slower  execution.  
  
As a general rule of style, you should use $? only when you don’t know the length of fields. Do not use $?  simply as a typing convenience.  
The Ideal Bachelor  
Variables used in patterns have an important and useful property, which can be stated as follows.  
  
The first time a variable is bound it retains that value only within the rule, both on the LHS and also on the  RHS, unless changed on the RHS.  
For example, in the rule below  
(defrule bound  
 (number-1 ?num)  
 (number-2 ?num)  
=>) 
If there are some facts  
f-1 (number-1 0)  
f-2 (number-2 0)  
f-3 (number-1 1)  
f-4 (number-2 1)  
then the rule can only be activated by the pair f-1, f-2, and the other pair f-3, f-4. That is, fact f-1  cannot match with f-4 because when ?num is bound to 0 in the first pattern, the value of ?num in  the second pattern also must be 0. Likewise, when ?num is bound to 1 in the first pattern, the  value of ?num in the second pattern must be 1. Notice that the rule will be activated twice by these  four facts: one activation for the pair f-1, f-2, and the other activation for the pair f-3, f-4.  
As a more practical example, enter the following rule. Notice that the same variable, ?name,  is used in both patterns. Before doing a (reset) and (run), also enter a (watch all) command so that  you can see what happens during execution.  
CLIPS> (clear)  
CLIPS>  
(defrule ideal-duck-bachelor  
 (bill big ?name)  
 (feet wide ?name)  
=>  
 (printout t "The ideal duck is "  
 ?name crlf))  
CLIPS>  
(deffacts duck-assets  
 (bill big Dopey)  
 (bill big Dorky)  
 (bill little Dicky)  
 (feet wide Dopey)  
 (feet narrow Dorky)  
 (feet narrow Dicky))  
CLIPS> (watch facts)  
CLIPS> (watch activations)  
CLIPS> (reset)  
==> f-1 (bill big Dopey)  
==> f-2 (bill big Dorky)  
==> f-3 (bill little Dicky)  
==> f-4 (feet wide Dopey) 
==> Activation 0 ideal-duck-bachelor: f-1,f-4  ==> f-5 (feet narrow Dorky)  
==> f-6 (feet narrow Dicky)  
CLIPS> (run)  
The ideal duck is Dopey  
CLIPS>  
When the program is run, the first pattern matches Dopey and Dorky since they both have big  bills. The variable ?name is bound to each name. When CLIPS tries to match the second pattern  of the rule, only the variable ?name which is bound to Dopey also satisfies the second pattern of  (feet wide).  
The Lucky Duck  
Many situations occur in life where it’s wise to do things in a systematic manner. That way, if  your expectations don’t work out you can try again systematically (such as the common algorithm  for finding the Perfect Spouse by getting married over and over again).  
One way of being organized is to keep a list. (Note: if you really want to impress people, show  them a list of your lists.) In our case, we’ll keep a list of duck bachelors, with the most likely  prospect for matrimony at the front. Once an ideal duck bachelor has been identified, we’ll shoot  him up to the front of the list as the lucky duck.  
The following program shows how this can be done by adding a couple of rules to the ideal duck-bachelor rule.  
(defrule ideal-duck-bachelor  
 (bill big ?name)  
 (feet wide ?name)  
=>  
 (printout t "The ideal duck is "  
 ?name crlf)  
 (assert (move-to-front ?name)))  
(defrule move-to-front  
 ?move-to-front <- (move-to-front ?who)  
 ?old-list <-  
 (list $?front ?who $?rear)  
=>  
 (retract ?move-to-front ?old-list) 
 (assert (list ?who ?front ?rear))  
 (assert (change-list yes)))  
(defrule print-list  
 ?change-list <- (change-list yes)  
 (list $?list)  
=>  
 (retract ?change-list)  
 (printout t "List is : " ?list crlf))  
(deffacts duck-bachelor-list  
 (list Dorky Dinky Dicky))  
(deffacts duck-assets  
 (bill big Dicky)  
 (bill big Dorky)  
 (bill little Dinky)  
 (feet wide Dicky)  
 (feet narrow Dorky)  
 (feet narrow Dinky))  
The original list is given in the duck-bachelor-list deffacts. When the program is run, it will  provide a new list of likely candidates.  
CLIPS> (unwatch all)  
CLIPS> (reset)  
CLIPS> (run)  
The ideal duck is Dicky  
List is : (Dicky Dorky Dinky)  
CLIPS>  
Notice the assertion (change-list yes) in the move-to-front rule. Without this assertion, the print list rule would always fire on the original list. This assertion is an example of a control fact made to control the firing of another rule. Control facts are very important in controlling the  activation of certain rules, and you should study this example carefully to understand why it’s  used. Another method of control is modules, as discussed in the CLIPS Reference Manual.  
The move-to-front rule removes the old list and asserts the new list. If the old list was not  retracted, two activations would be on the agenda for the print-list rule but only one would fire.  Only one will fire because the print-list rule removes the control fact required for the other 
activation of the same rule. You would not know in advance which one would fire, so the old list  might be printed instead of the new list. 
Chapter 5  
Doing It Up In Style  
Style today, gone tomorrow  
In this chapter, you will learn about a keyword called deftemplate, which stands for define  template. This feature can aid you in writing rules whose patterns have a well-defined structure.  
Mr. Wonderful  
Deftemplate is analogous to a struct definition in C. That is, the deftemplate defines a group of  related fields in a pattern similar to the way in which a C struct is a group of related data. A  deftemplate is a list of named fields called slots. Deftemplate allows access by name rather than  by specifying the order of fields. Deftemplate contributes to good style in expert systems  programs and is a valuable tool of software engineering. 
A slot is a named single-slot or multislot. A single-slot or simply slot contains exactly one  field while a multislot contains zero or more fields. Any number of single or multislot slots may be  used in a deftemplate. To write a slot, give the field name (attribute) followed by the field value.  Note that a multislot slot with one value is strictly not the same as a single-slot slot. As an analogy,  think of a cupboard (the multislot) that may contain dishes. A cupboard with one dish is not the  same as a dish (single-slot). However, the value of a single-slot slot (or variable) may match a  multislot slot (or multislot variable) that has one field.  
As an example of a deftemplate relation, consider the attributes of a duck who might be  considered a good matrimonial prospect:  
name 
"Dopey Wonderful" 
assets 
rich 
age 
99
A deftemplate may be defined for the relation prospect as follows, where white space and  comments are used for readability and explanation.  
; name of deftemplate relation  
(deftemplate prospect  
 ; optional comment in quotes  
 "vital information"  
 ; name of field  
 (slot name  
 ; type of field  
 (type STRING)  
 ; default value of field name  
 (default ?DERIVE))  
 ; name of field  
 (slot assets  
 ; type of field  
 (type SYMBOL)  
 ; default value of field assets  
 (default rich))  
 ; name of field  
 (slot age  
 ; type. NUMBER can be  
 ; INTEGER or FLOAT  
 (type NUMBER)  
 ; default value of field age  
 (default 80)))  
In this example, the components of deftemplate are structured as:  
• A deftemplate relation name  
• Attributes called fields 
• The field type, which can be any one of the allowed types: symbol, string, number, and  others.  
• The default for the field value  
This particular deftemplate has three single-slot slots called name, assets, and age. 
The deftemplate default values are inserted by CLIPS when a (reset) is done if no  explicit values are defined. For example, enter the deftemplate for prospect after a (clear)  command, and assert it as shown.  
CLIPS> (assert (prospect))  
<Fact-1>  
CLIPS> (facts)  
f-1 (prospect (name "") (assets rich) (age 80))  For a total of 1 fact.  
CLIPS>  
As you can see, CLIPS has inserted the default value of the null string, "", for the name field  since that is the default for a STRING. Likewise, the assets and age defaults were also inserted by  CLIPS. Different types have different default symbols such as the null string, "", for STRING; the  integer 0 for INTEGER; the float 0.0 for FLOAT; and so on. The ?DERIVE keyword selects the  appropriate type of constraint for that slot, e.g., the null string , "", for a slot of type STRING.  
You can explicitly set the field values, as the following example shows.  
CLIPS>  
(assert (prospect (age 99)  
 (name "Dopey")))  
<Fact-2>  
CLIPS> (facts)  
f-1 (prospect (name "") (assets rich) (age 80))  f-2 (prospect (name "Dopey") (assets rich) (age 99))  For a total of 2 facts.  
CLIPS>  
Note that the order that the fields are typed in does not matter since these are named fields.  
In the deftemplate, it’s important to realize that NUMBER is not a primitive field type like  symbol, string, integer, and float. The NUMBER is really a compound type that can be integer or float. It is used for cases in which the user doesn’t care what type of numbers are stored. An  alternative to NUMBER would be specifying the types as follows.  
(slot age  
 (type INTEGER FLOAT)  
 (default 80))) 
Bye-Bye  
In general, a deftemplate with N slots has the following general structure:  
(deftemplate <name>  
 (slot-1)  
 (slot-2)  
 .  
 .  
 .  
 (slot-N))  
In a deftemplate, the attribute values may be specified more precisely than a simple value such as  80 or rich. For example, in this deftemplate, a type of value is specified.  
The field values can be specified by either explicitly listing them or giving a range of values.  The allowed-values can be any primitive type such as SYMBOL, STRING, INTEGER, FLOAT  and so on. Some examples of deftemplate enumerated values are shown following:  
allowed-symbols 
rich filthy-rich loaded 
allowed-strings 
"Dopey" "Dorky" "Dicky" 
allowed-numbers 
1 2 3 4.5 -2.001 1.3e-4 
allowed-integers 
-100 53 
allowed-floats 
-2.3 1.0 300.00056 
allowed-values 
"Dopey" rich 99 1.e9 
It doesn’t make sense to specify both a numeric range and values allowed for the same  deftemplate field. For example, if you specify (allowed-integers 1 4 8), this contradicts a range  specification of 1 to 10 by (range 1 10). If the numbers happen to be sequential, such as 1, 2, 3,  then you could specify a range which would exactly match: (range 1 3). However, the range  would be redundant to the allowed-integers specification. Thus, range and allowed values are 
mutually exclusive. That is, if you specify a range, you can’t specify the allowed values and vice versa.  In general, the range attribute cannot be used in conjunction with allowed-values, allowed numbers, allowed-integers, or allowed-floats.  
Without the optional information, the deftemplate and a rule which uses it follows.  
CLIPS> (clear)  
CLIPS>  
; name of deftemplate  
(deftemplate prospect  
 ; name of field  
 (slot name  
 ; default value of field name  
 (default ?DERIVE))  
 ; name of field  
 (slot assets  
 ; default value of field assets  
 (default rich))  
 ; name of field  
 (slot age  
 ; default value of field age  
 (default 80)))  
CLIPS>  
(defrule matrimonial_candidate  
 (prospect (name ?name)  
 (assets ?net_worth)  
 (age ?months))  
=>  
 (printout t "Prospect: "  
 ?name crlf  
 ?net_worth crlf  
 ?months " months old"  
 crlf))  
CLIPS>  
(assert  
 (prospect (name "Dopey Wonderful")  
 (age 99)))  
<Fact-1>  
CLIPS> (run) 
Prospect: Dopey Wonderful  
rich  
99 months old  
CLIPS>  
Notice that the default value of rich was used for Dopey since the assets field was not specified in  the assert command.  
If the assets field is given a specific value such as poor, the specified value for assets of poor overrides the default value of rich as shown in the following example about Dopey’s penurious  nephew.  
CLIPS> (reset)  
CLIPS>  
(assert  
 (prospect (name "Dopey Notwonderful")  
 (assets poor)  
 (age 95)))  
<Fact-1>  
CLIPS> (run)  
Prospect: "Dopey Notwonderful"  
poor  
95 months old  
CLIPS>  
A deftemplate pattern may be used just like any ordinary pattern. For example, the following rule  will eliminate undesirable prospects.  
CLIPS> (undefrule matrimonial_candidate)  
CLIPS>  
(defrule bye-bye  
 ?bad-prospect <-  
 (prospect (assets poor)  
 (name ?name))  
=>  
 (retract ?bad-prospect)  
 (printout t "bye-bye " ?name crlf))  
CLIPS> (reset)  
CLIPS>  
(assert 
 (prospect (name "Dopey Wonderful")  
 (assets rich)))  
<Fact-1>  
CLIPS>  
(assert  
 (prospect (name "Dopey Notwonderful")  
 (assets poor)))  
<Fact-2>  
CLIPS> (run)  
bye-bye Dopey Notwonderful  
CLIPS>  
Ain’t No Strings on Me  
Notice that only single fields were used for the patterns in the examples so far. That is, the field  values for name, assets, and age, were all single values. In some types of rules, you may want  multiple fields. Deftemplate allows the use of multiple values in a multislot.  
As an example of multislot, suppose that you wanted to treat the name of the relation prospect as multiple fields. This would provide more flexibility in processing prospects since any part of  the name could be pattern matched. Shown following is the deftemplate definition using multislot  and the revised rule to pattern match on multiple fields. Notice that a multislot pattern, $?name,  is now used to match all the fields that make up the name. For convenience, a (deffacts) is also  given.  
CLIPS> (clear)  
CLIPS>  
(deftemplate prospect  
 (multislot name  
 (type SYMBOL)  
 (default ?DERIVE))  
 (slot assets  
 (type SYMBOL)  
 (allowed-symbols  
 poor rich wealthy loaded)  
 (default rich))  
 (slot age  
 (type INTEGER) ; The older  
 (range 80 ?VARIABLE) ; the 
 (default 80))) ; better!!!  
CLIPS>  
(defrule happy_relationship  
 (prospect (name $?name)  
 (assets ?net_worth)  
 (age ?months))  
=>  
 (printout t "Prospect: "  
 ; Note: not $?name  
 ?name crlf  
 ?net_worth crlf  
 ?months " months old"  
 crlf))  
CLIPS>  
(deffacts duck-bachelor  
 (prospect (name Dopey Wonderful)  
 (assets rich)  
 (age 99)))  
CLIPS> (reset)  
CLIPS> (run)  
Prospect: (Dopey Wonderful)  
rich  
99 months old  
CLIPS>  
In the output, the parentheses around Dopey’s name are put in by CLIPS to indicate that this is a  multislot value. If you compare the output from this multislot version to the single-slot version,  you’ll see that the double quotes around “Dopey Wonderful” are gone. The name slot is not a  string in the multislot version, so CLIPS treats the name as two independent fields, Dopey and  Wonderful.  
What’s in a Name  
Deftemplate greatly simplifies accessing a specific field in a pattern because the desired field can  be identified by its slot name. The modify action can be used to modify a fact in one action by  specifying one or more template slots to be modified. 
As an example, consider the following rules which show what happens when duck-bachelor  Dopey Wonderful loses all his fish buying Donald Duck posters and banana fishsplits for his new  duckette, Dixie.  
CLIPS> (undefrule *)  
CLIPS>  
(defrule make-bad-buys  
 ?prospect <- (prospect (name $?name)  
 (assets rich)  
 (age ?months))  
=>  
 (printout t "Prospect: "  
 ; Note: not $?name  
 ?name crlf  
 "rich" crlf  
 ?months " months old"  
 crlf crlf)  
 (modify ?prospect (assets poor)))  
CLIPS>  
(defrule poor-prospect  
 ?prospect <- (prospect (name $?name)  
 (assets poor)  
 (age ?months))  
=>  
 (printout t "Ex-prospect: "  
 ; Note: not $?name  
 ?name crlf  
 poor crlf  
 ?months " months old"  
 crlf crlf))  
CLIPS>  
(deffacts duck-bachelor  
 (prospect (name Dopey Wonderful)  
 (assets rich)  
 (age 99)))  
CLIPS> (reset)  
CLIPS> (run)  
Prospect: (Dopey Wonderful)  
rich 
99 months old  
Ex-prospect: (Dopey Wonderful)  
poor  
99 months old  
CLIPS>  
If you do a (facts) command as follows, you’ll see that the f-1 fact originally corresponding to  (prospect (assets rich) (age 99) (name Dopey Wonderful)) has been modified and the assets slot has  been set to poor.  
CLIPS> (facts)  
f-1 (prospect (name Dopey Wonderful)  
 (assets poor) (age 99))  
For a total of 1 fact.  
CLIPS>  
The make-bad-buys rule is activated by a rich prospect as specified by the assets slot. This rule  changes the assets to poor using the modify action. Notice that the slot assets can be accessed by  name. Without a deftemplate, it would be necessary to enumerate all the fields by single variables  or by using a wildcard, which is less efficient. The purpose of the poor-prospect rule is simply to  print out the poor prospects, thus demonstrating that the make-bad-investments rule did indeed  modify the assets. 
Chapter 6  
Being Functional  
Functionality is the inverse of style  
In this chapter, you will learn more powerful functions for matching patterns and some that are  very useful with multifield variables. You also will learn how numeric calculations are done.  
Not My Constraint  
Let’s reconsider the problem of designing an expert system to help a robot cross a street. One  rule that you would have follows.  
(defrule green-light  
 (light green)  
=>  
 (printout t "Walk" crlf))  
Another rule would cover the case of a red light.  
(defrule red-light  
 (light red)  
=>  
 (printout t "Don't walk" crlf))  
A third rule would cover the case in which a walk-sign said not to walk. This would take  precedence over a green light.  
(defrule walk-sign  
 (walk-sign-says dont-walk)  
=>  
 (printout t "Don't walk" crlf))  
The previous rules are simplified and don’t cover all cases such as the breakdown of the traffic light. For example, what does the robot do if the light is red or yellow and the walk-sign says  walk? 
A way of handling this case is to use a field constraint to restrict the values that a pattern  may have on the LHS. The field constraint acts like constraints on patterns.  
One type of field constraint is called a connective constraint. There are three types of  connective constraints. The first is called a ~ constraint. Its symbol is the tilde, “~”. The ~  constraint acts on the one value that immediately follows it and will not allow that value.  
As a simple example of the ~ constraint, suppose you wanted to write a rule that would print  out “Don't walk” if the light was not green. One approach would be to write rules for every  possible light condition, including all possible malfunctions: yellow, red, blinking yellow, blinking  red, blinking green, winking yellow, blinking yellow and winking red, and so forth. However, a  much easier approach is to use the ~ constraint as shown in the following rule:  
(defrule walk  
 (light ~green)  
=>  
 (printout t "Don't walk" crlf))  
By using the ~ constraint, this one rule does the work of many other rules that required  specifying each light condition.  
Be Cautious  
The second connective constraint is the bar constraint, “|”. The “|” connective constraint is  used to allow any of a group of values to match.  
For example, suppose you wanted a rule that printed out “Be cautious” if the light was yellow  or blinking yellow. The following example shows how it’s done using the “|” constraint.  
CLIPS> (clear)  
CLIPS>  
(defrule cautious  
 (light yellow|blinking-yellow)  
=>  
 (printout t "Be cautious" crlf))  
CLIPS> (assert (light yellow))  
<Fact-1>  
CLIPS> (assert (light blinking-yellow))  
<Fact-2>  
CLIPS> (agenda) 
0 cautious: f-2  
0 cautious: f-1  
For a total of 2 activations.  
CLIPS>  
And Away We Go  
The third type of connective constraint is the & connective constraint. The symbol of the &  connective constraint is the ampersand, “&”. The & constraint forces connected constraints to  match in union, as you’ll see in the following examples. The & constraint normally is used only  with the other constraints, otherwise it’s not of much practical use. As an example, suppose you  want to have a rule that will be triggered by a yellow or blinking-yellow fact. That’s easy enough —just use the | connective constraint as you did in a previous example. But suppose that you also  want to identify the light color?  
The solution is to bind a variable to the color that is matched using the “&” and then print  out the variable. This is where the “&” is useful, as shown below.  
(defrule cautious  
 (light ?color&yellow|blinking-yellow)  
=>  
 (printout t  
 "Be cautious because light is "  
 ?color crlf))  
The variable ?color will be bound to whatever color is matched by the field yellow|blinking yellow.  
The “&” also is useful with the “~”. For example, suppose you want a rule that triggers when  the light is not yellow and not red.  
(defrule not-yellow-red  
 (light ?color&~red&~yellow)  
=>  
 (printout t "Go, since light is "  
 ?color crlf)) 
It’s Elementary  
Besides dealing with symbolic facts, CLIPS also can perform numeric calculations. However, you  should keep in mind that an expert system language like CLIPS is not primarily designed for  number-crunching. Although the math functions of CLIPS are very powerful, they are really  meant for modification of numbers that are being reasoned about by the application program.  Other languages such as FORTRAN are better for number-crunching in which little or no  symbolic reasoning is being done. You’ll find the computational capability of CLIPS useful in  many applications.  
CLIPS provides basic arithmetic and math functions +, /, *, -, div, max, min, abs, float, and  integer. For more details, see the CLIPS Reference Manual.  
Numeric expressions are represented in CLIPS according to the style of LISP. In both LISP  and CLIPS, a numeric expression that customarily would be written as 2 + 3 must be written in  prefix form, (+ 2 3). In the prefix form of CLIPS, the function precedes the arguments, and  parentheses must surround the numeric expression. The customary way of writing numeric  expressions is called infix form because the math functions are fixed in between the  arguments.  
Functions can be used on the LHS and the RHS. For example, the following shows how the  arithmetic operation of addition is used on the RHS of a rule to assert a fact containing the sum  of two numbers ?x and ?y. Note that the comments are in infix notation for your information  only since infix cannot be evaluated by CLIPS.  
CLIPS> (clear)  
CLIPS>  
(defrule addition  
 (numbers ?x ?y)  
=>  
 ; Add ?x + ?y  
 (assert (answer-plus (+ ?x ?y))))  
CLIPS> (assert (numbers 2 3))  
<Fact-1>  
CLIPS> (run)  
CLIPS> (facts)  
f-1 (numbers 2 3)  
f-2 (answer-plus 5)  
For a total of 2 facts.  
CLIPS> 
A function can be used on the LHS if an equal sign, =, is used to tell CLIPS to evaluate the  following expression rather than use it literally for pattern matching. The following example  shows how the hypotenuse is calculated on the LHS and used to pattern match against some  stock items. The exponentiation, “**”, function is used to square the x and y values. The first  argument of exponentiation is the number which is to be raised to the power of the second  argument.  
CLIPS> (clear)  
CLIPS>  
(deffacts database  
 (stock A 2.0)  
 (stock B 5.0)  
 (stock C 7.0))  
CLIPS>  
(defrule addition  
 (numbers ?x ?y)  
 ; Hypotenuse  
 (stock ?ID =(sqrt (+ (** ?x 2)  
 (** ?y 2))))  
=>  
 (printout t "Stock ID=" ?ID crlf))  
CLIPS> (reset)  
CLIPS> (assert (numbers 3 4))  
<Fact-4>  
; Stock ID matches  
; hypotenuse calculated  
CLIPS> (run)  
Stock ID=B  
CLIPS>  
Extensive Arguments  
Arguments in a numeric expression can be extended beyond two for many of the math functions.  The same sequence of arithmetic calculations is performed for more than two arguments. The  following example illustrates how three arguments are used. Evaluation proceeds from left to  right. Before entering these, however, you may wish to do a (clear) to get rid of any old facts and  rules. 
(defrule addition  
 (numbers ?x ?y ?z)  
=>  
 ; ?x + ?y + ?z  
 (assert (answer-plus (+ ?x ?y ?z))))  
Enter the above program and assert (numbers 2 3 4). After you run, you’ll see the following facts.  Note that the fact-indices may be different if you’ve done a (reset) instead of a (clear) before  loading this program.  
CLIPS> (facts)  
f-1 (numbers 2 3 4)  
f-2 (answer-plus 9)  
For a total of 2 facts.  
CLIPS>  
The infix equivalent of a multiple argument CLIPS expression can be expressed as  arg [function arg]  
where the square brackets mean that there can be multiple terms.  
Besides the basic math functions, CLIPS has Extended Math functions including trig,  hyperbolic, and so on. For a complete list, see the CLIPS Reference Manual. These are called  Extended Math functions because they are not considered basic math functions like “+”, “-”, etc.  
Mixed Results  
In dealing with expressions, CLIPS tries to keep the mode the same as the arguments. For  example,  
; both integer arguments  
; give integer result  
CLIPS> (+ 2 2)  
4  
; both floating-point arguments  
; give floating-point result  
CLIPS> (+ 2.0 2.0)  
4.0  
; mixed arguments  
; give floating-point result 
CLIPS> (+ 2 2.0)  
4.0  
CLIPS>  
Notice that in the last case of mixed arguments, CLIPS converts the result to standard double precision floating-point type.  
You can explicitly convert one type to another by using the float and integer functions, as  demonstrated in the following examples.  
; convert integer  
; to float  
CLIPS> (float (+ 2 2))  
4.0  
; convert float  
; to integer  
CLIPS> (integer (+ 2.0 2.0))  
4  
CLIPS>  
Parentheses are used to explicitly specify the order of expression evaluation if desired. In the  example of ?x + ?y * ?z, the customary infix way to evaluate it is to multiply ?y by ?z and then  add the result to ?x. However, in CLIPS, you must write the precedence explicitly if you want this  order of evaluation, as follows.  
(defrule mixed-calc  
 (numbers ?x ?y ?z)  
=>  
 ; ?y * ?z + ?x  
 (assert (answer (+ ?x (* ?y ?z)))))  
In this rule, the expression in the innermost parentheses is evaluated first; so ?y is multiplied by ? z. The result is added to ?x.  
Bound Bachelors  
The analog to assigning a value to a variable on the LHS by pattern matching is binding a value  to a variable on the RHS using the bind function. It’s convenient to bind variables on the RHS  if the same values will be repeatedly used. 
As a simple example in a math calculation, let’s first bind the answer to a variable and then  print the bound variable.  
CLIPS> (clear)  
CLIPS>  
(defrule addition  
 (numbers ?x ?y)  
=>  
 (assert (answer (+ ?x ?y)))  
 (bind ?answer (+ ?x ?y))  
 (printout t "answer is "  
 ?answer crlf))  
CLIPS> (assert (numbers 2 2))  
<Fact-1>  
CLIPS> (run)  
answer is 4  
CLIPS> (facts)  
f-1 (numbers 2 2)  
f-2 (answer 4)  
For a total of 2 facts.  
CLIPS>  
The (bind) also can be used on the RHS to bind single or multifield values to a variable. The  (bind) is used to bind zero, one, or more values to a variable without the “$” operator. Recall that on  the LHS, you can only create a multifield pattern by using the “$” operator on a field, such as “$? x”. However, the “$” is unnecessary on the RHS because the arguments of (bind) explicitly tell  CLIPS exactly how many values to bind. In fact, the “$” is a useless appendage on the RHS.  
The following rule illustrates some variable bindings on the RHS. The multifield value  function, create$, is used to create a multifield value. Its general syntax is as follows.  
(create$ <arg1> <arg2> ... <argN>)  
where any number of arguments can be appended together to create a multifield value. This  multifield value, or a single-field value, can then be bound to a variable as shown in the RHS  actions of the following rule.  
CLIPS> (clear)  
CLIPS>  
(defrule bind-values-demo 
=>  
 (bind ?duck-bachelors  
 (create$ Dopey Dorky Dinky))  
 (bind ?happy-bachelor-mv  
 (create$ Dopey))  
 (bind ?none (create$))  
 (printout t  
 "duck-bachelors "  
 ?duck-bachelors crlf  
 "duck-bachelors-no-() "  
 (implode$ ?duck-bachelors) crlf  
 "happy-bachelor-mv "  
 ?happy-bachelor-mv crlf  
 "none " ?none crlf))  
CLIPS> (reset)  
CLIPS> (run)  
duck-bachelors (Dopey Dorky Dinky)  
duck-bachelors-no-() Dopey Dorky Dinky  
happy-bachelor-mv (Dopey)  
none ()  
CLIPS>  
Doing Your Own Thing  
Just like other languages, CLIPS allows you to define your own functions with deffunction. The  deffunction is known globally, which saves you the effort of entering the same actions over and  over again.  
Deffunctions also help in readability. You can call a deffunction just like any other function. A  deffunction may also be used as the argument of another function. A (printout) can be used  anywhere in a deffunction even if it’s not the last action because printing is a side-effect of calling  the (printout) function.  
The general syntax of a deffunction is shown following.  
(deffunction <function-name>  
 [optional comment]  
 ; argument list. Last one may  
 ; be optional multifield arg. 
 (?arg1 ?arg2 ... ?argM [$?argN])  
 ; action1 to action(K-1)  
 ; do not return a value  
 ; only last action returned  
 (<action1>  
 <action2>  
 ...  
 <action(K-1)>  
 <actionK>)  
The ?arg are dummy arguments, which mean that the names of the arguments will not  conflict with variable names in a rule if they are the same. The term dummy argument is  sometimes called a parameter in other books.  
Although each action may have returned values from function calls within the action, these  are blocked by the deffunction from being returned to the user. The deffunction will only return  the value of the last action, <actionK>. This action may be a function, a variable, or a constant.  
The following is an example of how a deffunction is defined to calculate the hypotenuse, and  then used in a rule. Even if the variable names in the rule are the same as the dummy arguments,  there’s no conflict. That’s why they’re dummy, because they don’t mean anything.  
CLIPS> (clear)  
CLIPS>  
(deffunction hypotenuse ; name  
 ; dummy arguments  
 (?a ?b)  
 ; action  
 (sqrt(+ (* ?a ?a) (* ?b ?b))))  
CLIPS>  
(defrule calculate-hypotenuse  
 (dimensions ?base ?height)  
=>  
 (printout t "Hypotenuse="  
 (hypotenuse ?base ?height)  
 crlf))  
CLIPS> (assert (dimensions 3 4))  
<Fact-1>  
CLIPS> (run) 
Hypotenuse=5.0  
CLIPS>  
Deffunctions may be used with multifield values, as the following example shows.  
CLIPS> (clear)  
CLIPS>  
(deffunction count ($?arg)  
 (length$ $?arg))  
CLIPS> (count 1 2 3 a duck "quacks")  
6  
CLIPS>  
Other Features  
Other useful functions follow. For more information, see the CLIPS Reference Manual.  
round: Round toward closest integer. If exactly between two integers, rounds toward  negative infinity.  
integer: Truncates the decimal part of a number.  
format: Formats output.  
list-deffunctions: List all deffunctions.  
ppdeffunction: Pretty print deffunction.  
undeffunction: Deletes a deffunction if it is not currently executing and not referred to  elsewhere. Specifying “*” for <name> deletes all.  
length$: Number of fields, or the number of characters in a string or symbol.  nth$: Specified field if it exists, else nil.  
member$: Number of the field if literal or variable exists, else FALSE.  
subsetp: Returns TRUE if a multi field value is a subset of another multifield value, else  FALSE.  
delete$: Given a field number, deletes the value in the field.  
explode$: Each string element is returned as part of a new multifield value.  subseq$: Returns a specified range of fields.  
replace$: Replaces a specified value. 
Chapter 7  
How to Be in Control  
When you’re young, you’re controlled by the world, when you’re older, you  
should control the world  
Up to this point, you’ve been learning the basic syntax of CLIPS. Now you’ll see how to apply  the syntax you’ve learned to more powerful and complex programs. You’ll also learn some new  syntax for input, and see how to compare values and generate loops.  
Let’s Start Reading  
Besides matching a pattern, a rule can get information in another way. CLIPS can read the  information that you type from the keyboard using the read function.  
The following example shows how (read) is used to input data. Note that no extra (crlf) is  needed after the (read) to put the cursor on a new line. The (read) automatically resets the cursor  to a new line.  
CLIPS> (clear)  
CLIPS>  
(defrule read-input  
=>  
 (printout t "Name a primary color"  
 crlf)  
 (assert (color (read))))  
CLIPS>  
(defrule check-input  
 ?color <-  
 (color ?color-read&red|yellow|blue)  
=>  
 (retract ?color)  
 (printout t "Correct" crlf))  
CLIPS> (reset)  
CLIPS> (agenda)  
0 read-input: * 
For a total of 1 activation.  
CLIPS> (run)  
Name a primary color  
red  
Correct  
CLIPS> (reset)  
CLIPS> (run)  
Name a primary color  
green  
CLIPS> ; No "correct" 
The rule is designed to use keyboard input on the RHS, so it’s convenient to trigger the rule by  not specifying any patterns on the LHS so it will automatically be activated when a (reset) occurs.  When the activation for the read-input rule is displayed by the (agenda) command, an * is printed  rather than a fact identifier such as f-1. The * is used to indicate that the pattern is satisfied, but  not by a specific fact.  
The (read) function is not a general-purpose function that will read anything you type on the  keyboard. One limitation is that (read) will read only one field. So if you try to read  
primary color is red  
only the first field, “primary”, will be read. To (read) all the input, you must enclose the input  within double quotes. Of course, once the input is within double quotes, it is a single literal field.  You can then access the substrings “primary”, “color”, “is”, and “red” with the str-explode or  sub-string functions.  
The second limitation of (read) is that you can’t input parentheses unless they are within  double quotes. Just as you can’t assert a fact containing parentheses, you can’t (read) parentheses  directly except as literals.  
The readline function is used to read multiple values until terminated by a carriage return.  This function reads in data as a string. In order to assert the (readline) data, an (assert-string)  function is used to assert the nonstring fact, just as input by (readline). A top-level example of  (assert-string) follows.  
CLIPS> (clear)  
CLIPS>  
(assert-string "(primary color is red)")  
<Fact-1>  
CLIPS> (facts) 
f-1 (primary color is red)  
For a total of 1 fact.  
CLIPS>  
Notice that the argument of (assert-string) must be a string The following shows how to assert a  fact of multiple fields from (readline).  
CLIPS> (clear)  
CLIPS>  
(defrule test-readline  
=>  
 (printout t "Enter input" crlf)  
 (bind ?string (readline))  
 (assert-string  
 (str-cat "(" ?string ")")))  
CLIPS> (reset)  
CLIPS> (run)  
Enter input  
primary color is red  
CLIPS> (facts)  
f-1 (primary color is red)  
For a total of 1 fact.  
CLIPS>  
Since (assert-string) requires parentheses around the string to be asserted, the (str-cat) function is  used to put them around ?string.  
Both (read) and (readline) also can be used to read information from a file by specifying the  logical name of the file as the argument. For more information, see the CLIPS Reference Manual.  
Being Efficient  
CLIPS is a rule-based language that uses a very efficient pattern-matching algorithm called the  Rete Algorithm, devised by Charles Forgy of Carnegie-Mellon University for his OPS shell.  The term Rete is Latin for net, and describes the software architecture of the pattern-matching  process.  
It is very difficult to give precise rules that will always improve the efficiency of a program  running under the Rete Algorithm. However, the following should be taken as general guidelines  that may help: 
1. Put the most specific patterns in a rule first. Patterns with unbound variables and  wildcards should be lower down in the list of rule patterns. A control fact should be put  first in the patterns.  
2. Patterns with fewer matching facts should go first to minimize partial matches.  
3. Patterns that are often retracted and asserted, volatile patterns, should be put last in  the list of patterns.  
As you can see, these guidelines are potentially contradictory. A non-specific pattern may have  few matches (see guidelines 1 and 2). Where should it go? The overall guideline is to minimize  changes of the partial matches from one cycle of the Inference Engine to the next. This may  require much effort by the programmer in watching partial matches. An alternative solution is  simply to buy a faster computer, or an accelerator board. This is becoming more attractive since  the price of hardware always goes down while the price of human labor always goes up. Because  CLIPS is designed for portability, any code developed on one machine should work on another.  
Other Features  
The test conditional element provides a very powerful way by which to compare numbers,  variables, and strings on the LHS. The (test) is used as a pattern on the LHS. A rule will only be  triggered if the (test) is satisfied together with other patterns.  
Many predefined functions are provided by CLIPS. Logical functions are:  not: Boolean not 
and: Boolean and 
or: Boolean or 
Arithmetic functions are:  
/: Division  
*: Multiplication  
+: Addition  
-: Subtraction  
Comparison functions are:  
eq: Equal (any type). Compares type and magnitude.  
neq: Not equal (any type). 
=: Equal (numeric type). Compares magnitude.  
<>: Not equal (numeric type).  
>=: Greater than or equal to  
>: Greater than.  
<=: Less than or equal to.  
<: Less than.  
All the comparison functions except “eq” and “neq” will give an error message if they are used to  compare a number and non-number. If the type is not known in advance, the “eq” and “neq”  functions should be used. The eq function checks for the same magnitude and type of its  arguments while the “=” function only checks the magnitude of its (numeric) arguments and  doesn’t care if they’re integer or floating-point.  
The logical functions of CLIPS are and, or, and not. They can be used in expressions as  Boolean functions. In CLIPS, true and false are represented by the symbols TRUE and FALSE.  Note that upper-case must be used for logical values in CLIPS.  
In addition to all the predefined functions, you may write external functions or user defined functions in C, Ada, or other procedural languages and link to CLIPS. These external  functions are then used as you would any predefined function.  
CLIPS also gives you the capability of specifying an explicit and conditional element, an  or conditional element, and a not conditional element on the LHS. The absence of a fact  is specified as a pattern on the LHS using the “not” conditional element.  
The alteration of our information to conform to reality is called truth maintenance. That  is, we try to maintain the state of our minds to contain only true information so as to minimize  conflicts with the real world.  
While people can do this fairly easily (practice makes perfect), it’s difficult for computers  because they don’t normally know which pattern entities are logically dependent on other  pattern entities. CLIPS has a feature to support truth maintenance which will internally tag those  pattern entities which are logically dependent on others. If these other pattern entities are  retracted, CLIPS will automatically retract the logically dependent ones. The logical  conditional element uses the keyword logical around a pattern to indicate that the matching  pattern entities provide logical support to the assertions on the RHS.  
Although the logical support works for assertions, it does not reassert retracted facts. The moral  is, if you lose something due to erroneous information, you can’t get it back (like losing money on  your stockbrokers advice.) 
CLIPS has two functions to help with logical support. The dependencies function lists the  partial matches from which a pattern entity receives logical support, or none if there is no  support. The second logic function is dependents which lists all pattern entities which receive  logical support from a pattern entity.  
The connective constraint, uses “&”, “|”, or “~”. Another type of field constraint is called a  predicate constraint and is often used for pattern matching of more complex fields. The  purpose of a predicate constraint is to constrain a field depending on the result of a Boolean  expression. If the Boolean returns FALSE, the constraint is not satisfied and the pattern  matching fails. You’ll find that the predicate constraint is very useful with numeric patterns.  
A predicate function is one which returns a FALSE or a non-FALSE value. The colon,  “:” followed by a predicate function is called a predicate constraint. The ":" may be preceded  by “&”, “|”, or “~” or may stand by itself as in the pattern (fact :(> 2 1)). It is typically used with  the & connective constraint as “&:”. The following list contains some of the predicate functions  defined by CLIPS:  
(evenp <arg>): Check if <arg> is even number.  
(floatp <arg>): Check if <arg> is floating-point number.  
(integerp <arg>): Check if <arg> is integer.  
(lexemep <arg>): Check if <arg> is symbol or string.  
(multifieldp <arg>): Check if <arg> is multifield value.  
(numberp <arg>): Check if <arg> is float or integer.  
(oddp <arg>): Check if <arg> is odd number.  
(pointerp <arg>): Check if <arg> is external address.  
(stringp <arg>): Check if <arg> is string.  
(symbolp <arg>): Check if <arg> is symbol.  
There are often cases in which it’s convenient to have values which are globally known in an  expert system. For example, it is inefficient to have to redefine universal constants such as π.  CLIPS provides the defglobal construct so that values may be universally known to all rules.  
Another type of useful function is random numbers. CLIPS has a random function which  returns a “random” integer value. The random number function of CLIPS actually returns  pseudorandom numbers, which means they are not truly random but are generated by a  mathematical formula. For most purposes the pseudorandom numbers will be fine. Note that the  random function of CLIPS uses the ANSI C library function rand which may not be available on 
all computers that do not adhere to this standard. For more information on all these topics, please  see the CLIPS Reference Manual. 
In addition to control facts to control the execution of programs, CLIPS provides a more  direct way of control by the explicit assignment of salience to rules. The main problem associated  with explicitly using salience while you were just starting to learn CLIPS is the tendency to  overuse salience and write sequential programs. This overuse defeats the whole purpose of using  a rule-based language, which is to provide a natural vehicle for those applications best  represented by rules. In the same way, procedural languages are best for strong control-oriented  applications, while object-oriented languages are best for representing objects. CLIPS has  keywords called declare salience which can be used to explicitly set the priority of rules.  
Salience is set using a numeric value ranging from the smallest value of -10000 to the highest  of 10000. If a rule has no salience explicitly assigned by the programmer, CLIPS assumes a  salience of zero. Notice that a salience of zero is midway between the largest and smallest  salience values. A salience of zero does not mean that the rule has no salience but, rather, that it  has an intermediate priority level.  
CLIPS provides some procedural programming structures that can be used on the RHS.  These structures are the while and if then else that also are found in modern high-level  languages such as Ada, C, and Java.  
Another useful function with (while) loops is break which ends the currently executing  (while) loop. The return function immediately ends the currently executing deffunction, generic  function, method, or message-handler.  
Any function may be called from the RHS, which greatly contributes to the power of CLIPS.  Many other CLIPS functions are available that may return with numbers, symbols, or strings.  These functions may be used for their return values or for their side-effects. An example of a  function only used for its side-effect is (printout). The value returned by (printout) is meaningless.  The importance of (printout) is in its side-effect of output. In general, functions may have nested  arguments if appropriate to your desired effect.  
Before a file can be accessed for reading or writing, it must be opened using the open function. The number of files that can be opened at once is dependent on your operating system  and hardware. When you no longer need to access a file, you should close it with the close function. Unless a file is closed, there is no guarantee that the information written to it will be  saved.  
The logical name of a file is how CLIPS identifies the file. The logical name is a global  name by which CLIPS knows this file in all rules. Although the logical name could be identical to